<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Alex Robenko">
<title>Guide to Implementing Communication Protocols in C&#43;&#43; (for Embedded Systems)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Guide to Implementing Communication Protocols in C&#43;&#43; (for Embedded Systems)</h1>
<div class="details">
<span id="author" class="author">Alex Robenko</span><br>
<span id="revnumber">version 1.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#_code_generation_vs_c_library">Code Generation vs C&#43;&#43; Library</a></li>
<li><a href="#_main_challenges">Main Challenges</a></li>
<li><a href="#intro-goal">Goal</a></li>
<li><a href="#_audience">Audience</a></li>
<li><a href="#_code_examples">Code Examples</a></li>
<li><a href="#_final_outcome">Final Outcome</a></li>
<li><a href="#_contribution">Contribution</a></li>
</ul>
</li>
<li><a href="#_message">Message</a>
<ul class="sectlevel2">
<li><a href="#message-read_write">Reading and Writing</a></li>
<li><a href="#message-dispatch_handle">Dispatching and Handling</a></li>
<li><a href="#message-extend_interface">Extending Interface</a></li>
</ul>
</li>
<li><a href="#fields-fields">Fields</a>
<ul class="sectlevel2">
<li><a href="#fields-automation">Automating Basic Operations</a></li>
<li><a href="#fields-access">Working With Fields</a></li>
<li><a href="#fields-common_types">Common Field Types</a></li>
</ul>
</li>
<li><a href="#library-library">Generic Library</a>
<ul class="sectlevel2">
<li><a href="#library-interface">Generalising Message Interface</a></li>
<li><a href="#library-impl">Generalising Message Implementation</a></li>
<li><a href="#library-fields">Generalising Fields Implementation</a></li>
</ul>
</li>
<li><a href="#transport-transport">Transport</a>
<ul class="sectlevel2">
<li><a href="#transport-payload">PAYLOAD Layer</a></li>
<li><a href="#transport-id">ID Layer</a></li>
<li><a href="#transport-size">SIZE Layer</a></li>
<li><a href="#transport-sync">SYNC Layer</a></li>
<li><a href="#transport-checksum">CHECKSUM Layer</a></li>
<li><a href="#transport-stack">Defining Protocol Stack</a></li>
</ul>
</li>
<li><a href="#final">Achievements</a></li>
<li><a href="#appendix">Appendices</a>
<ul class="sectlevel2">
<li><a href="#appendix-a">Appendix A - tupleForEach</a></li>
<li><a href="#appendix-b">Appendix B - tupleAccumulate</a></li>
<li><a href="#appendix-c">Appendix C - tupleForEachFromUntil</a></li>
<li><a href="#appendix-d">Appendix D - tupleForEachType</a></li>
<li><a href="#appendix-e">Appendix E - AlignedUnion</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Almost every electronic device/component nowadays has to be able to communicate
to other devices, components, or outside world over some I/O link. Such
communication is implemented using various communication protocols.</p>
</div>
<div class="paragraph">
<p>At first glance the implementation of communication protocols seems to be
quite an easy and straightforward process. Every message has predefined
fields, that need to be serialised and deserialised according to the protocol
specification. Every serialised message is wrapped in a transport data to ensure
a safe delivery to the other end over some I/O link. However, there are multiple
pitfalls and wrong design choices that can lead to a cumbersome, bloated, and
difficult to maintain source code. It becomes especially noticable when the development of the
product progresses, and initially developed small communication protocol grows to
contain many more messages than initially planned. Adding a new message in
such state can become a tedious, time consuming and error-prone process.</p>
</div>
<div class="paragraph">
<p>This book suggests flexible, generic and easily extendable design architecture,
which allows creation of a generic C&#43;&#43;(11) library. This library may be
used later on to implement many binary communication protocols using simple
declarative statements of class and type definitions.</p>
</div>
<div class="paragraph">
<p>As stated in the book&#8217;s title, the main focus of this book is a development
for embedded systems (including bare-metal ones). There is no use of
RTTI and/or exceptions.
I also make a significant effort to minimise usage of dynamic memory allocation
and provide means to exclude it altogether if needed. All the presented techniques and
design choices are also applicable to non-embedded systems which don&#8217;t have
limitations of the latter.</p>
</div>
<div class="paragraph">
<p>This work is licensed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cc-by-nd.png" alt="Image: Creative Commons License">
</div>
</div>
<div class="sect2">
<h3 id="_code_generation_vs_c_library">Code Generation vs C&#43;&#43; Library</h3>
<div class="paragraph">
<p>The implementation of the binary communication
protocols can be a tedious, time consuming and error-prone process.
Therefore, there is a growing tendency among developers to use third party code
generators for data (de)serialisation. Usually such tools receive description
of the protocol data layout in separate source file(s) with a custom grammar,
and generate appropriate (de)serialisation code and necessary abstractions to
access the data.</p>
</div>
<div class="paragraph">
<p>There are so many of them:
<a href="https://developers.google.com/protocol-buffers/">ProtoBuf</a>,
<a href="https://capnproto.org/">Cap&#8217;n Proto</a>, <a href="http://msgpack.org/index.html">MessagePack</a>,
<a href="https://thrift.apache.org/">Thrift</a>, <a href="http://kaitai.io/">Kaitai Struct</a>,
<a href="https://www.protlr.com/">Protlr</a>, you-name-it&#8230;&#8203;
All of these tools are capable of generating <strong>C&#43;&#43;</strong> code. However,
the generated code quite often is not good enough to be used in embedded systems, especially
bare-metal ones. Either the produced <strong>C&#43;&#43;</strong> code or the tool itself has
<strong>at least</strong> one of the following limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inability to specify binary data layout. Many of the tools use their own
serialisation format without an ability to provide custom one. It makes them
impossible to use to implement already defined and used binary communication
protocol.</p>
</li>
<li>
<p>Inability to customise underlying types. Most (or all) of the mentioned code
generating tools, which do allow customisation of binary data layout,
choose to use <strong>std::string</strong> for string fields and/or
<strong>std::vector</strong> for lists, as well as (de)serialisation code is generated to use
standard streams (<strong>std::istream</strong> and <strong>std::ostream</strong>). Even if such ability
is provided, it is usually "global" one and do not allow substitution of types only for
specific messages / fields.</p>
</li>
<li>
<p>Small number of supported data fields or limited number of their serialisation options.
For example, strings can be serialised by being prefixed with their size
(which in turn can have different lengths), or being terminated with <code>'\0'</code>, or
having fixed size with <code>'\0'</code> padding if the string is too short. There are
protocols that use all three variants of strings.</p>
</li>
<li>
<p>Poor or weak description grammar without an ability to support conditional
(de)serialisation. For example, having a value
(such as single bit in some bitmask field) which determines whether some other
optional field exists or not.</p>
</li>
<li>
<p>Lack of polymorphic interface to allow implementation of the common code for all the
defined messages.</p>
</li>
<li>
<p>When polymorphic interface with virtual functions is provided, there is no
way to exclude generation of unnecessary virtual functions for a particular embedded application.
All the provided virtual functions will probably remain in the final image even
if they are not used.</p>
</li>
<li>
<p>Lack of efficient built-in way of dispatching the deserialised message object into
its appropriate handling function. There is a need to provide a separate
dispatch table or map from message ID to some callback function or object.</p>
</li>
<li>
<p>Lack of ability to override or complement the generated serialisation code with the manually
written one where extra logic is required.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generalisation is hard. Especially when the main focus of the tools'
developers is on supporting as many target programming languages as possible,
rather than allowing multiple configuration variants of a single specific
language. Currently there is no universal <strong>fit all needs</strong> code generation
solution that can handle all the existing and being used binary communication protocols.
As the result many embedded C&#43;&#43; developers still have to manually implement
them rather than relying on the existing tools for code generation.</p>
</div>
<div class="paragraph">
<p>There is still a way to help them in such endeavour by
developing a C&#43;&#43; library which will provide highly configurable classes, usage
of which will allow to implement required functionality using simple declarative
statements of types and classes definitions (instead of implementing everything
from scratch). That&#8217;s what this book is all about.</p>
</div>
<div class="paragraph">
<p>Thanks to new language features introduced in <strong>C&#43;&#43;11</strong> standard and multiple
meta-programming techniques, it becomes possible to write simple, clear, but
highly configurable code, which can be used in multiple applications: embedded
bare-metal with limited resources, Linux based platform, even the GUI analysis
tools. They all can use the same single implementation of the protocol, but
each generate the code suitable for the developed platform / application. The
C&#43;&#43; compiler itself serves as code generation tool.</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_challenges">Main Challenges</h3>
<div class="paragraph">
<p>There are multiple challenges that need to be considered prior to starting
implementation of any communication protocol. It will guide us into the
right direction when designing an overall architecture.</p>
</div>
<div class="sect3">
<h4 id="_code_boilerplating">Code Boilerplating</h4>
<div class="paragraph">
<p>The communication protocols are notorious for creating a
<a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a>.
As a whole, most of them are very similar, they define
various messages with their internal fields, define serialisation rules for all
the fields and wrap them in some kind of transport information to ensure safe
delivery of the message over the I/O link.</p>
</div>
<div class="paragraph">
<p>When serialising any message, all its fields must be serialised in predefined
order. There is also very limited number of field types that is usually used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>numeric values</strong> - may differ in sizes, being signed or unsigned, have a different
ranges of valid values, etc&#8230;&#8203;</p>
</li>
<li>
<p><strong>enumeration values</strong> - similar to numeric values, but have a very limited range
of valid values, and <code>enum</code> type is usually used to operate the values, just for
convenience.</p>
</li>
<li>
<p><strong>bitmask values</strong> - similar to numeric values, but each bit has a different
meaning.</p>
</li>
<li>
<p><strong>strings</strong> - may differ in the way they are serialised (zero-suffixed or size-prefixed).</p>
</li>
<li>
<p><strong>lists</strong> of raw bytes or other fields - may have fixed (predefined) or
variable size.</p>
</li>
<li>
<p><strong>bundles of multiple fields</strong> - may be used as a single element of a <strong>list</strong>.</p>
</li>
<li>
<p><strong>bitfields</strong> - similar to bundles, but internal member fields have a length of
several bits (instead of bytes).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of field types is quite small, but the number of different nuances when
serialising or using a single field is much bigger. It is very difficult to
generalise such use and most developers don&#8217;t even bother to come up with
something generic. As the result they experience a <strong>deja-vu</strong> feeling every time
they have to implement a new message or add a new field into an existing message.
There is a strong feeling that the code is being duplicated, but there is no
obvious and/or easy way to minimise it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_protocol_extension_effort">Protocol Extension Effort</h4>
<div class="paragraph">
<p>Keep in mind the development effort that will be required to introduce
a new message to the protocol being implemented. The number of different places
in the existing code base, that need to be modified/updated, must obviously be
kept at a minimum. Ideally no more than 2 or 3, but most implementations I&#8217;ve
seen significantly bypass these numbers. In many cases developers forget
to introduce compile time checks, such as <code>static_assert</code> statements to
verify that all the required places in the code have been updated after new
message was introduced. Failure to do so results in unexpected bugs and extended
development effort to find and fix them.</p>
</div>
<div class="paragraph">
<p>What about extending an existing message by adding an extra field at the end or
even in the middle? How easy is it going to be and how much development time needs
to be spent? How error-prone is it going to be?</p>
</div>
</div>
<div class="sect3">
<h4 id="_inter_system_reuse">Inter-System Reuse</h4>
<div class="paragraph">
<p>Quite often the implementation of the same protocol needs to be reused between
different systems. For example, some embedded sensor device needs to communicate its
data to a management server (both implemented in C&#43;&#43;) and it would be wise to
share the same implementation of the communication protocol on both ends.
However, managing the I/O link and usage of various data structures may
be different for both of them. Making the implementation of the communication
protocol system dependent may make such reuse impossible.</p>
</div>
<div class="paragraph">
<p>Sometimes different teams are responsible for implementation of different systems,
that use the same communication protocol but that reside on different ends of
the communication link. Usually such teams make an
upfront decision not to share the implementation of the communication
protocol they use. Even in this case, making the implementation
system dependent is a bad idea. It may be necessary to
develop some additional protocol testing tools because the other team has not
completed the development of their product in time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_intra_system_reuse">Intra-System Reuse</h4>
<div class="paragraph">
<p>It is not uncommon for various embedded systems to add extra I/O interfaces
in the next generations of the device hardware, which can be used to communicate with
other devices using the same protocol. For example, the first generation of
some embedded sensor communicates its data over TCP/IP network link to
some data management server. The second generation adds a Bluetooth interface
that allows to communicate the same data to a tablet of the person working nearby.
The application level messages, used to communicate the data,
are the same for the server and the tablet.
However, the transport wrapping information for TCP/IP and Bluetooth will
obviously differ. If initial implementation of the communication protocol
hasn&#8217;t properly separated the application level messages and wrapping transport
data, it&#8217;s going to be difficult, time consuming and error-prone to introduce
a new communication channel via Bluetooth I/O link.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="intro-goal">Goal</h3>
<div class="paragraph">
<p>Our primary goal is to come up with an architecture that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>does NOT depend or make any assumptions on the system it is running on.</p>
</li>
<li>
<p>does NOT make any hard-coded assumptions on the resources available to the system, such
as dynamic memory allocation, exceptions, RTTI, etc&#8230;&#8203;</p>
</li>
<li>
<p>has an <strong>efficient</strong> way to parse the incoming message and dispatch it to an
appropriate handler. The runtime complexity shouldn&#8217;t exceed <code>O(log(n))</code>,
where <code>n</code> is a total number of messages in the protocol.</p>
</li>
<li>
<p>provides quick, easy and straightforward way of adding new messages to the
protocol.</p>
</li>
<li>
<p>has as little connection as possible between the application level messages
and wrapping transport data, which allows easy substitution of the latter if
need arises.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our ultimate goal would be creation of a generic C&#43;&#43;(11) library, that can
assist in implementation of many binary communication protocols. Such
library will provide all the necessary types and classes, usage of which will make the
implementation of the required communication protocol easy, quick and
straightforward process of using simple declarative statements.
It will significantly reduce the amount of boilerplate code and boost the
development process.</p>
</div>
</div>
<div class="sect2">
<h3 id="_audience">Audience</h3>
<div class="paragraph">
<p>The primary intended audience of this book is <strong>intermediate</strong> to
<strong>professional</strong> C&#43;&#43; developers who feel comfortable with templates and are
not afraid of template meta-programming.</p>
</div>
<div class="paragraph">
<p>In order to achieve all our <a href="#intro-goal">goals</a> of platform and runtime environment
independence, there is little other choice but to use templates with significant
amount of meta-programming techniques in order to allow compiler to generate
the best code suitable for the system being developed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_code_examples">Code Examples</h3>
<div class="paragraph">
<p>This book contains multiple C&#43;&#43; code examples and snippets. Their main
purpose is to demonstrate ideas expressed in the book as well as guide
developers into the right direction. There are no huge code listings
(nobody reads them anyway) and no detailed explanations for every line of code. I
expect the readers to understand the demonstrated idea and take it to the next
level themselves.</p>
</div>
<div class="paragraph">
<p>In order to demonstrate the idea I rarely use <strong>production</strong> level code, at
least not up front. I will start with something simple and non-generic and
gradually increase the complexity and/or genericity.</p>
</div>
<div class="paragraph">
<p>I&#8217;m also a huge fan of
<a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface (NVI) Idiom</a>
and often my examples will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeInterface</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">someFunction</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">someFunctionImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">someFunctionImpl</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SomeInterface</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">someFunctionImpl</span><span class="p">()</span> <span class="k">override</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The non virtual interface function is supposed to check pre- and
post-conditions of the polymorphic invocation if such exist as well as execute
some common code if such is required. I tend to write the code similar to
above even when there are no pre- and post-conditions to check and no common
code to execute. Please don&#8217;t be surprised when seeing such constructs throughout
the book.</p>
</div>
</div>
<div class="sect2">
<h3 id="_final_outcome">Final Outcome</h3>
<div class="paragraph">
<p>The ideas summarised in this book are not just <em>theoretical</em> ones. There is
ready to use implementation called
<a href="https://github.com/commschamp/comms_champion#comms-library">COMMS Library</a>.
It provides all the necessary types and classes to
make the definition of the custom messages as well as wrapping transport data
fields to be simple declarative statements of type and class definitions,
which specify <strong>WHAT</strong> needs to be implemented. The library internals handle
the <strong>HOW</strong> part.</p>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that the ideas expressed in this book are very basic ones, the
mentioned <a href="https://github.com/commschamp/comms_champion#comms-library">COMMS Library</a>
is much more advanced than the examples provided in this book. It is recommended
to read the library&#8217;s tutorial and, as an excersice, to think about ways how the
provided examples can be extended to support the described features.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/commschamp/comms_champion#comms-library">COMMS Library</a>
is a part of a bigger project called
<a href="https://github.com/commschamp/comms_champion">CommsChampion</a>.
It contains generic plug-in based tools for visualisation and analysis of
the communication protocols, which have been implemented using the
provided library.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contribution">Contribution</h3>
<div class="paragraph">
<p>If you have any suggestions, requests, bug fixes, spelling mistakes fixes,
or maybe you feel that some things are not explained properly,
please feel free to e-mail me to <strong>arobenko@gmail.com</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_message">Message</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most C&#43;&#43; developers intuitively choose to express every independent message as
a separate class, which inherit from a common interface.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message.png" alt="Image: Message class hierarchy">
</div>
</div>
<div class="paragraph">
<p>This is a step to the <strong>right</strong> direction.
It becomes easy and convenient to write a common code that suites all
possible messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(...)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">writeImpl</span><span class="p">(...);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="c1">// Implements writing to a buffer functionality</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span>

<span class="c1">// Send any message</span>
<span class="kt">void</span> <span class="nf">sendMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">write</span><span class="p">(...);</span> <span class="c1">// write message to a buffer</span>
    <span class="p">...</span><span class="c1">// send buffer contents over I/O link;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="message-read_write">Reading and Writing</h3>
<div class="paragraph">
<p>When new raw data bytes are received over some I/O link, they need to be
deserialised into the custom message object, then dispatched to an appropriate
handling function. When continuing <strong>message as an object</strong> concept, expressed in
previous chapter, it becomes convenient to make a reading/writing functionality
a responsibility of the message object itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(...)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">readImpl</span><span class="p">(...);</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(...)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeImpl</span><span class="p">(...);</span>
    <span class="p">}</span>
    <span class="p">...</span>

<span class="nl">protected:</span>
    <span class="c1">// Implements reading from the buffer functionality</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(...)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Implements writing to a buffer functionality</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(...)</span> <span class="k">override</span> <span class="p">{...};</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(...)</span> <span class="k">override</span> <span class="p">{...};</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(...)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is obviously a need to know success/failure status of the read/write operation.
The <code>ErrorStatus</code> return value may be defined for example like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorStatus</span>
<span class="p">{</span>
    <span class="n">Success</span><span class="p">,</span>
    <span class="n">NotEnoughData</span><span class="p">,</span>
    <span class="n">BufferOverflow</span><span class="p">,</span>
    <span class="n">InvalidMsgData</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume, that at the stage of parsing transport wrapping information, the
ID of the message was retrieved and appropriate actual message object was
created in an <strong>efficient</strong> way. This whole process will be described later in
the <a href="#transport-transport">Transport</a> chapter.</p>
</div>
<div class="paragraph">
<p>Once the appropriate message object was created and returned in some kind of
smart pointer, just call the <code>read(&#8230;&#8203;)</code> member function of the message object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">MsgPtr</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">processTransportData</span><span class="p">(...)</span>
<span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">read</span><span class="p">(...);</span> <span class="c1">// read message payload</span>
<span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle error</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_data_structures_independence">Data Structures Independence</h4>
<div class="paragraph">
<p>One of our <a href="#intro-goal">goals</a> was to make the implementation
of the communication protocol to be system independent.
In order to make the code as generic as possible we have to eliminate any dependency
on specific data structures, where the incoming raw bytes are stored before being
processed, as well as outgoing data before being sent out.</p>
</div>
<div class="paragraph">
<p>The best way to achieve such independence is to use
<a href="http://en.cppreference.com/w/cpp/concept/Iterator">iterators</a> instead of
specific data structures and make it a responsibility of the caller to maintain
appropriate buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIter</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="n">TReadIter</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="n">TWriteIter</span><span class="p">;</span>

    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>

<span class="nl">protected:</span>
    <span class="c1">// Implements reading from the buffer functionality</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Implements writing to a buffer functionality</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIter</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">TReadIter</span><span class="p">,</span> <span class="n">TWriteIter</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">TReadIter</span><span class="p">,</span> <span class="n">TWriteIter</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>
    <span class="p">...</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span> <span class="p">{...};</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that iterators are passed by reference, which allows the increment
and assignment operations required to implement serialisation/deserialisation
functionality.</p>
</div>
<div class="paragraph">
<p>Also note, that the same implementation of the read/write operations can be used
in any system with any restrictions. For example, the bare-metal embedded system
cannot use dynamic memory allocation and must serialise the outgoing messages
into a static array, which forces the definition of the write iterator to be
<code>std::uint8_t*</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">EmbReadIter</span> <span class="o">=</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span> <span class="n">EmbWriteIter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span> <span class="n">EmbMessage</span> <span class="o">=</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">EmbReadIter</span><span class="p">,</span> <span class="n">EmbWriteIter</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">EmbActualMessage1</span> <span class="o">=</span> <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">EmbReadIter</span><span class="p">,</span> <span class="n">EmbWriteIter</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">EmbActualMessage2</span> <span class="o">=</span> <span class="n">ActualMessage2</span><span class="o">&lt;</span><span class="n">EmbReadIter</span><span class="p">,</span> <span class="n">EmbWriteIter</span><span class="o">&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="mi">1024</span><span class="o">&gt;</span> <span class="n">outBuf</span><span class="p">;</span>
<span class="n">EmbWriteIter</span> <span class="n">iter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">outBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">EmbActualMessage1</span> <span class="n">msg</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">outBuf</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">auto</span> <span class="n">writtenCount</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">iter</span><span class="p">);</span> <span class="c1">// iter was incremented</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Linux server system which resides on the other end of
the I/O link doesn&#8217;t have such limitation and uses <code>std::vector&lt;std::uint8_t&gt;</code>
to store outgoing serialised messages. The generic and data structures independent
implementation above makes it possible to be reused:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">LinReadIter</span> <span class="o">=</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span> <span class="n">LinWriteIter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">LinMessage</span> <span class="o">=</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">LinReadIter</span><span class="p">,</span> <span class="n">LinWriteIter</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">LinActualMessage1</span> <span class="o">=</span> <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">LinReadIter</span><span class="p">,</span> <span class="n">LinWriteIter</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">LinActualMessage2</span> <span class="o">=</span> <span class="n">ActualMessage2</span><span class="o">&lt;</span><span class="n">LinReadIter</span><span class="p">,</span> <span class="n">LinWriteIter</span><span class="o">&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">outBuf</span><span class="p">;</span>
<span class="n">LinWriteIter</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">outBuf</span><span class="p">);</span>

<span class="n">LinActualMessage1</span> <span class="n">msg</span><span class="p">;</span>
<span class="n">msg</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">outBuf</span><span class="p">.</span><span class="n">max_size</span><span class="p">());</span>
<span class="k">auto</span> <span class="n">writtenCount</span> <span class="o">=</span> <span class="n">outBuf</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_data_serialisation">Data Serialisation</h4>
<div class="paragraph">
<p>The <code>readImpl()</code> and <code>writeImpl()</code> member functions of the actual message
class are supposed to properly serialise and deserialise message fields. It is
a good idea to provide some common serialisation functions accessible by the
actual message classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIter</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>readData()</code> and <code>writeData()</code> static member functions above are responsible
to implement the serialisation and deserialisation of the values using the
right endian.</p>
</div>
<div class="paragraph">
<p>Depending on a communication protocol there may be a need to serialise only part
of the value. For example, some field of communication protocol is defined
to have only 3 bytes. In this case the value will probably be stored in a
variable of <code>std::uint32_t</code> type. There must be similar set of functions,
but with additional template parameter that specifies how many bytes to read/write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIter</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>CAUTION</strong>: The interface described above is very easy and convenient to use
and quite easy to implement using straightforward approach. However, any
variation of template parameters create an instantiation of new binary code,
which may create significant code bloat if not used carefully.
Consider the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read/write of signed vs unsigned integer values. The serialisation/deserialisation
code is identical for both cases, but won&#8217;t be considered as such when
instantiating the functions. To optimise this case, there is a need to
implement read/write operations only for unsigned value, while the “signed”
functions become wrappers around the former. Don&#8217;t forget a sign extension
operation when retrieving partial signed value.</p>
</li>
<li>
<p>The read/write operations are more or less the same for any length of the
values, i.e of any types: (unsigned) char, (unsigned) short, (unsigned) int, etc&#8230;&#8203;
To optimise this case, there is a need for internal function that receives
length of serialised value as a run time parameter, while the functions
described above are mere wrappers around it.</p>
</li>
<li>
<p>Usage of the iterators also require caution. For example reading values may
be performed using regular <code>iterator</code> as well as <code>const_iterator</code>, i.e.
iterator pointing to <code>const</code> values. These are two different iterator types
that will duplicate the “read” functionality if both of them are used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All the consideration points stated above require quite complex implementation
of the serialisation/deserialisation functionality with multiple levels of
abstraction which is beyond the scope of this book.
It would be a nice exercise to try and implement them yourself.
You may take a look at
<a href="https://github.com/commschamp/comms_champion/blob/master/comms/include/comms/util/access.h">util/access.h</a>
file in the
<a href="https://github.com/commschamp/comms_champion#comms-library">COMMS Library</a>
of the <a href="https://github.com/commschamp/comms_champion">comms_champion</a> project
for reference.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-dispatch_handle">Dispatching and Handling</h3>
<div class="paragraph">
<p>When a new message arrives, its appropriate object is created, and the contents
are deserialised using <code>read()</code> member function, described in previous chapter.
It is time to dispatch it to an appropriate handling function. Many developers
use the <code>switch</code> statement or even a sequence of <code>dynamic_cast</code>-s to identify
the real type of the message object and call appropriate handling function.</p>
</div>
<div class="paragraph">
<p>When it comes to <code>switch</code> statements modern compilers are capable of generating
efficient dispatch tables. However, the code itself is manual and boilerplate.
There is a much better way of doing a dispatch
operation by using a C&#43;&#43; ability to differentiate between functions with the
same name but with different parameter types. It is called
<a href="https://en.wikipedia.org/wiki/Double_dispatch">Double Dispatch Idiom</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a handling class <code>Handler</code> that is capable of handling
all possible messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the definition of the messages may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// invokes handle(ActualMessage1&amp;);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// invokes handle(ActualMessage2&amp;);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following code will invoke appropriate handling function
in the <code>Handler</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">MsgPtr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// any custom message object;</span>
<span class="n">Handler</span> <span class="n">handler</span><span class="p">;</span>

<span class="n">msg</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span> <span class="c1">// will invoke right handling function.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that the <code>Message</code> interface class doesn&#8217;t require the definition
of the <code>Handler</code> class, the forward declaration
of the latter is enough. The <code>Handler</code> also doesn&#8217;t require
the definitions of all the actual messages being available, forward declarations of all
the message classes will suffice. Only the implementation part of the <code>Handler</code>
class will require knowledge about the interface of the messages being handled.
However, the public interface of the <code>Handler</code> class must be known when
compiling <code>dispatchImpl()</code> member function of any <code>ActualMessageX</code> class.</p>
</div>
<div class="sect3">
<h4 id="_eliminating_boilerplate_code">Eliminating Boilerplate Code</h4>
<div class="paragraph">
<p>You may also notice that the body of all <code>dispatchImpl()</code> member functions in
all the <code>ActualMessageX</code> classes is going to be the same:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span>
<span class="p">{</span>
    <span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that <code>*this</code> expression in every function evaluates to the
object of different type.</p>
</div>
<div class="paragraph">
<p>The apperent code duplication may be eliminated using
<a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern">Curiously Recurring Template Pattern</a>
idiom.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TDerived</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage2</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that <code>ActualMessageX</code> provide their own type as a template
parameter to their base class <code>MessageBase</code> and do not require to implement
<code>dispatchImpl()</code> any more. The class hierarchy looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message_dispatch_hierarchy.png" alt="Image: Class hierarchy">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_limited_number_of_messages">Handling Limited Number of Messages</h4>
<div class="paragraph">
<p>What if there is a need to handle only limited number of messages, all the rest
just need to be ignored. Let&#8217;s assume the protocol defines 10 messages:
<code>ActualMessage1</code>, <code>ActualMessage2</code>, &#8230;&#8203;, <code>ActualMessage10</code>. The messages that
need to be handled are just <code>ActualMessage2</code> and <code>ActualMessage5</code>, all the rest
ignored. Then the definition of the <code>Handler</code> class will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage5</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// empty body</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, when compiling <code>dispatchImpl()</code> member function of <code>ActualMessage2</code>
and <code>ActualMessage5</code>, the compiler will generate invocation code for appropriate
<code>handle()</code> function. For the rest of the message classes, the best matching option
will be invocation of <code>handle(Message&amp;)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="message-dispatch_handle-polymorphic">Polymorphic Handling</h4>
<div class="paragraph">
<p>There may be a need to have multiple handlers for the same set of messages. It
can easily be achieved by making the <code>Handler</code> an abstract interface class and
defining its <code>handle()</code> member functions as virtual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActualHandler1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActualHandler2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>No other changes to dispatch functionality is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">MsgPtr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// any custom message object;</span>
<span class="n">AtualHandler1</span> <span class="n">handler1</span><span class="p">;</span>
<span class="n">AtualHandler2</span> <span class="n">handler2</span><span class="p">;</span>

<span class="c1">// Works for any handler</span>
<span class="n">msg</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">handler1</span><span class="p">);</span>
<span class="n">msg</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">handler2</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_generic_handler">Generic Handler</h4>
<div class="paragraph">
<p>Now it&#8217;s time to think about the required future effort of extending the
handling functionality when new messages are added to the protocol and their
respective classes are implemented. It is especially relevant when
<a href="#message-dispatch_handle-polymorphic">Polymorphic Handling</a> is involved. There is a need
to introduce new <code>virtual handle(&#8230;&#8203;)</code> member function for every new message
that is being added.</p>
</div>
<div class="paragraph">
<p>There is a way to delegate this job to the compiler using template specialisation.
Let&#8217;s assume, that all the message types, which need
to be handled, are bundled into a simple declarative statement of <code>std::tuple</code>
definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">AllMessages</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">ActualMessage1</span><span class="p">,</span>
    <span class="n">ActualMessage2</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the definition of the generic handling class will be as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// TCommon is common interface class for all the messages</span>
<span class="c1">// TAll is all the message types, that need to be handled, bundled in std::tuple</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TAll</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFirst</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TRest</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TFirst</span><span class="p">,</span> <span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">:</span>
                        <span class="k">public</span> <span class="n">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="n">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">handle</span><span class="p">;</span> <span class="c1">// Don't hide all handle() functions from base classes</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TFirst</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// By default call handle(TCommon&amp;)</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GenericHandler</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TCommon</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above generates <code>virtual handle(TCommon&amp;)</code> function for the common
interface class, which does nothing by default. It also creates a separate
<code>virtual handle(&#8230;&#8203;)</code> function for every message type provided in <code>TAll</code>
tuple. Every such function upcasts the message type to its interface class
<code>TCommon</code> and invokes the <code>handle(TCommon&amp;)</code>.</p>
</div>
<div class="paragraph">
<p>As the result simple declaration of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GenericHandler</span><span class="o">&lt;</span><span class="n">Message</span><span class="p">,</span> <span class="n">AllMessages</span><span class="o">&gt;</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to having the following class defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">...</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// do nothing</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From now on, when new message class is defined, just add it to the <code>AllMessages</code>
tuple definition. If there is a need to override the default behaviour for
specific message, override the appropriate message in the handling class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ActualHandler1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage2</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Handling ActualMessage2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Common handling function is invoked"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>REMARK</strong>: Remember that the <code>Handler</code> class was forward declared when
defining the <code>Message</code> interface class? Usually it looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that <code>Handler</code> is declared to be a <code>class</code>, which prevents it from being
a simple <code>typedef</code> of <code>GenericHandler</code>. Usage of <code>typedef</code> will cause compilation
to fail.</p>
</div>
<div class="paragraph">
<p><strong>CAUTION</strong>: The implementation of the <code>GenericHandler</code> presented above creates
a chain of <strong>N + 1</strong> inheritances for <strong>N</strong> messages defined in <code>AllMessages</code>
tuple. Every new class adds a single virtual function. Many compilers will
create a separate <code>vtable</code> for every such class. The size of every new <code>vtable</code>
is greater by one entry than a previous one. Depending on total number of
messages in that tuple, the code size may grow quite big due to growing number
of `vtable`s generated by the compiler. It may be not suitable for some
systems, especially bare-metal. It is possible to
significantly reduce number of inheritances using more template specialisation
classes. Below is an example of adding up to 3 virtual functions in a single
class at once. You may easily extend the example to say 10 functions or more.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TAll</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFirst</span><span class="p">,</span> <span class="n">TSecond</span><span class="p">,</span> <span class="n">TThird</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TRest</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TFirst</span><span class="p">,</span> <span class="n">TSecond</span><span class="p">,</span> <span class="n">TThird</span><span class="p">,</span> <span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">:</span>
                        <span class="k">public</span> <span class="n">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="n">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TRest</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">handle</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TFirst</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TSecond</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TThird</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFirst</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TSecond</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TFirst</span><span class="p">,</span> <span class="n">TSecond</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GenericHandler</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TFirst</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TSecond</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TCommon</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFirst</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TFirst</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GenericHandler</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TFirst</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TCommon</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TCommon</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GenericHandler</span><span class="o">&lt;</span><span class="n">TCommon</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GenericHandler</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">TCommon</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-extend_interface">Extending Interface</h3>
<div class="paragraph">
<p>Let&#8217;s assume the protocol was initially developed for some embedded system
which required very basic message interface of only <strong>read</strong> / <strong>write</strong> / <strong>dispatch</strong>.</p>
</div>
<div class="paragraph">
<p>The interface class definition was defined allowing iterators to be specified elsewhere:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="n">TReadIterator</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="n">TWriteIterator</span><span class="p">;</span>

    <span class="c1">// Read the message</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Write the message</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Dispatch to handler</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The intermediate class allowing common implementation of <code>dispatchImpl()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TDerived</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">TReadIterator</span><span class="p">,</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the actual message classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">TReadIterator</span><span class="p">,</span> <span class="n">TWriteIterator</span><span class="p">,</span> <span class="n">ActualMessage1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">TReadIterator</span><span class="p">,</span> <span class="n">TWriteIterator</span><span class="p">,</span> <span class="n">ActualMessage2</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, after a while a new application needs to be developed, which monitors
the I/O link and dumps all the message traffic into standard output and/or *.csv file. This
application requires knowledge about names of the messages, and it would be
convenient to add an appropriate function into the common message interface and
reuse the existing implementation. There is
one problem though, the code of the protocol is already written and used in
the embedded system, which does not require this additional functionality and
its binary code should not contain these extra functions.</p>
</div>
<div class="paragraph">
<p>One of the solutions can be to use preprocessor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="cp">#ifdef HAS_NAME
</span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">nameImpl</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>
<span class="nl">protected:</span>
<span class="cp">#ifdef HAS_NAME
</span>    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nameImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">protected:</span>
<span class="cp">#ifdef HAS_NAME
</span>    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nameImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"ActualMessage1"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span><span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such approach may work for some products, but not for others, especially ones
that developed by multiple teams. If one team developed a reference implementation
of the communication protocol being used and is an "owner" of the code,
then it may be difficult and/or impractical for other team to push required changes
upstream.</p>
</div>
<div class="paragraph">
<p>Another approach is to remove hard coded
inheritance relationship between <code>Message</code> interface class and intermediate
<code>MessageBase</code> class. Instead, provide the common interface class as a
template parameter to the latter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIternface</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TDerived</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TIternface</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span> <span class="p">{...};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>ActualMessage*</code> classes will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIternface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">TIternface</span><span class="p">,</span> <span class="n">ActualMessage1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIternface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">TIternface</span><span class="p">,</span> <span class="n">ActualMessage2</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, the initial embedded system may use the common protocol code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">EmbReadIterator</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">using</span> <span class="n">EmbWriteIterator</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">using</span> <span class="n">EmbMessage</span> <span class="o">=</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">EmbReadIterator</span><span class="p">,</span> <span class="n">EmbWriteIterator</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">EmbMessage1</span> <span class="o">=</span> <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">EmbMessage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">EmbMessage2</span> <span class="o">=</span> <span class="n">ActualMessage2</span><span class="o">&lt;</span><span class="n">EmbMessage</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The original class hierarchy preserved intact:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message_old_interface_hierarchy.png" alt="Image: Original class hierarchy">
</div>
</div>
<div class="paragraph">
<p>And when extended interface and functionality are required, just use extra
class inheritances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Define extended interface</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TReadIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ExtMessage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span><span class="o">&lt;</span><span class="n">TReadIterator</span><span class="p">,</span> <span class="n">TWriteIterator</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">nameImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nameImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Define extended messages</span>
<span class="o">&lt;</span><span class="k">typename</span> <span class="n">TInterface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ExtActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">TInterface</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nameImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"ActualMessage1"</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The new application that requires extended implementation may still reuse the
common protocol code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">NewReadIterator</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">using</span> <span class="n">NewWriteIterator</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">using</span> <span class="n">NewMessage</span> <span class="o">=</span> <span class="n">ExtMessage</span><span class="o">&lt;</span><span class="n">NewReadIterator</span><span class="p">,</span> <span class="n">NewWriteIterator</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">NewMessage1</span> <span class="o">=</span> <span class="n">ExtActualMessage1</span><span class="o">&lt;</span><span class="n">NewMessage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">NewMessage2</span> <span class="o">=</span> <span class="n">ExtActualMessage2</span><span class="o">&lt;</span><span class="n">NewMessage</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As a result, no extra modifications to the original source code of the
protocol implementation is required, and every team achieves their own goal.
Everyone is happy!!!</p>
</div>
<div class="paragraph">
<p>The extended class hierarchy becomes:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message_ext_interface_hierarchy.png" alt="Image: Extended class hierarchy">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fields-fields">Fields</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every message in any communication protocol has zero or more internal fields, which
get serialised in some predefined order and transferred as message payload over
I/O link.</p>
</div>
<div class="paragraph">
<p>Usually developers implement some
<a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a>
of explicitly reading and writing all message fields in appropriate functions,
such as <code>readImpl()</code> and <code>writeImpl()</code> described in
<a href="#message-read_write">Reading and Writing</a> chapter. The primary
disadvantage of this approach is an increased development effort when contents
of some message need to be modified, i.e. some new field is added,
or existing one removed, even when the type of an existing field changes.
Having multiple places in the code, that need to be updated, leads to
an increased chance of forgetting to update one of the places, or introducing
some silly error, which will take time to notice and fix.</p>
</div>
<div class="paragraph">
<p>This chapter describes how to automate basic operations, such as read and write,
i.e. to make it a responsibility of the compiler to generate appropriate code.
All the developer needs to do is to define the list of all the field types
the message contains, and let the compiler do the job.</p>
</div>
<div class="sect2">
<h3 id="fields-automation">Automating Basic Operations</h3>
<div class="paragraph">
<p>Let&#8217;s start with automation of read and write. In most cases the <code>read()</code>
operation of the message has to read <strong>all</strong> the fields the message
contains, as well as <code>write()</code> operation has to write <strong>all</strong> the fields of
the message.</p>
</div>
<div class="paragraph">
<p>In order to make the generation of appropriate read/write code to be a job of
the compiler we have to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide the same interface for every message field.</p>
</li>
<li>
<p>Introduce a meta-programming friendly structure to hold all the fields, such
as <code>std::tuple</code>.</p>
</li>
<li>
<p>Use meta-programming techniques to iterate over every field in the
bundle and invoke the required read/write function of
every field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s assume, all the message fields provide the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Value storage type definition</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Provide an access to the stored value</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Read (deserialise) and update internal value</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

    <span class="c1">// Write (serialise) internal value</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Get the serialisation length</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The custom message class needs to define its fields bundled in <code>std::tuple</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Field1</span> <span class="o">=</span> <span class="p">...</span>
    <span class="k">using</span> <span class="n">Field2</span> <span class="o">=</span> <span class="p">...</span>
    <span class="k">using</span> <span class="n">Field3</span> <span class="o">=</span> <span class="p">...</span>

    <span class="k">using</span> <span class="n">AllFields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
        <span class="n">Field1</span><span class="p">,</span>
        <span class="n">Field2</span><span class="p">,</span>
        <span class="n">Field3</span>
    <span class="o">&gt;</span><span class="p">;</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="p">...</span><span class="c1">// invoke read() member function of every field</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="p">...</span><span class="c1">// invoke write() member function of every field</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What remains is to implement automatic invocation of <code>read()</code> and
<code>write()</code> member function for every field in <code>AllFields</code> tuple.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at standard algorithm
<a href="http://en.cppreference.com/w/cpp/algorithm/for_each">std::for_each</a>.
Its last parameter is a functor object, which must define appropriate
<code>operator()</code> member function. This function is invoked for every element being
iterated over. What we need is something similar, but
instead of receiving iterators, it must receive a full tuple object, and the
<code>operator()</code> of provided functor must be able to receive any type, i.e. be a template
function.</p>
</div>
<div class="paragraph">
<p>As the result the signature of such function may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">tupleForEach</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>tuple</code> is l- or r-value reference to any <code>std::tuple</code> object, and <code>func</code> is
l- or r-value reference to a functor object that must define the following
public interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">MyFunc</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTupleElem</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TTupleElem</span><span class="o">&amp;&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementation of the`tupleForEach()` function described above can be a nice
exercise for practising some meta-programming skills.
<a href="#appendix-a">Appendix A - tupleForEach</a> contains the required code if help is required.</p>
</div>
<div class="sect3">
<h4 id="_implementing_read">Implementing Read</h4>
<div class="paragraph">
<p>In order to implement read functionality there is a need to define proper reading
functor class, which may receive any field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">FieldReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FieldReader</span><span class="p">(</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_status</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
        <span class="n">m_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span>
        <span class="n">m_len</span><span class="p">(</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Error occurred earlier, don't continue with read</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_status</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">m_iter</span><span class="p">,</span> <span class="n">m_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span> <span class="o">==</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_len</span> <span class="o">-=</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">m_status</span><span class="p">;</span>
    <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">m_iter</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">m_len</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the body of <code>readImpl()</code> member function of the actual message class
may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">AllFields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEach</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldReader</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From now on, any modification to the <code>AllFields</code> bundle of fields does NOT require
any additional modifications to the body of <code>readImpl()</code> function. It becomes
a responsibility of the compiler to invoke <code>read()</code> member function of all the
fields.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_write">Implementing Write</h4>
<div class="paragraph">
<p>Implementation of the write functionality is very similar. Below is the implementation
of the writer functor class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">FieldWriter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FieldWriter</span><span class="p">(</span><span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">,</span> <span class="n">WriterIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_status</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
        <span class="n">m_iter</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span>
        <span class="n">m_len</span><span class="p">(</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Error occurred earlier, don't continue with write</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_status</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">m_iter</span><span class="p">,</span> <span class="n">m_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_status</span> <span class="o">==</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_len</span> <span class="o">-=</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">ErrorStatus</span><span class="o">&amp;</span> <span class="n">m_status</span><span class="p">;</span>
    <span class="n">WriterIterator</span><span class="o">&amp;</span> <span class="n">m_iter</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">m_len</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the body of <code>writeImpl()</code> member function of the actual message class
may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">AllFields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriterIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEach</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldWriter</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like with reading, any modification to the <code>AllFields</code> bundle of fields does NOT require
any additional modifications to the body of <code>writeImpl()</code> function. It becomes
a responsibility of the compiler to invoke <code>write()</code> member function of all the
fields.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eliminating_boilerplate_code_2">Eliminating Boilerplate Code</h4>
<div class="paragraph">
<p>It is easy to notice that the body of <code>readImpl()</code> and <code>writeImpl()</code> of every
<code>ActualMessage*</code> class looks the same. What differs is the tuple of fields which
get iterated over.</p>
</div>
<div class="paragraph">
<p>It is possible to eliminate such duplication of boilerplate code by introducing
additional class in the class hierarchy, which receives a bundle of fields as
a template parameter and implements the required functions. The same
technique was used to eliminate boilerplate code for
<a href="#message-dispatch_handle">Dispatching and Handling</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Common interface class:</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="p">{...};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Message</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Message</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">AllFields</span> <span class="o">=</span> <span class="n">TFields</span><span class="p">;</span>

    <span class="c1">// Access to fields bundle</span>
    <span class="n">AllFields</span><span class="o">&amp;</span> <span class="n">fields</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_fields</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">AllFields</span><span class="o">&amp;</span> <span class="n">fields</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_fields</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">protected:</span>
   <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEach</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldReader</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriterIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEach</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldWriter</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">FieldReader</span> <span class="p">{</span> <span class="p">...</span> <span class="cm">/* same code as from earlier example */</span> <span class="p">};</span>
    <span class="k">class</span> <span class="nc">FieldWriter</span> <span class="p">{</span> <span class="p">...</span> <span class="cm">/* same code as from earlier example */</span> <span class="p">};</span>

    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All the <code>ActualMessage*</code> classes need to inherit from <code>MessageBase</code> while
providing their own fields. The right implementation of
<code>readImpl()</code> and <code>writeImpl()</code> is going to be generated by the compiler automatically for
every custom message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="k">using</span> <span class="n">ActualMessage2Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ActualMessage2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage2Fields</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The class hierarchy looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message_auto_fields_hierarchy.png" alt="Image: Class hierarchy">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_basic_operations">Other Basic Operations</h4>
<div class="paragraph">
<p>In addition to read and write, there are other operations that can be automated.
For example, the serialisation length of the full message is a summary of the
serialisation lengths of all the fields. If every field can report its serialisation
length, then the implementation may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lengthImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">lengthImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">lengthImpl</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">tupleAccumulate</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="mi">0U</span><span class="p">,</span> <span class="n">LengthCalc</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">LengthCalc</span>
    <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that example above used <code>tupleAccumulate()</code> function, which is
similar to <a href="http://en.cppreference.com/w/cpp/algorithm/accumulate">std::accumulate</a>.
The main difference is that binary operation function object, provided to the
function, must be able to receive any type, just like with <code>tupleForEach()</code>
described earlier. The code of <code>tupleAccumulate()</code> function can be found in
<a href="#appendix-b">Appendix B - tupleAccumulate</a>.</p>
</div>
<div class="paragraph">
<p>Another example is an automation of validity check. In most cases the message
is considered to be valid if <strong>all</strong> the fields are valid. Let&#8217;s assume that
every fields can also provide an information about validity of its data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Get validity information</span>
    <span class="kt">bool</span> <span class="n">valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of message contents validity check may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">valid</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">validImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">validImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">validImpl</span><span class="p">()</span> <span class="n">constImpl</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">tupleAccumulate</span><span class="p">(</span><span class="n">m_fields</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">ValidityCalc</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">ValidityCalc</span>
    <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">bool</span> <span class="n">valid</span><span class="p">,</span> <span class="k">const</span> <span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">field</span><span class="p">.</span><span class="n">valid</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_overriding_automated_default_behaviour">Overriding Automated Default Behaviour</h4>
<div class="paragraph">
<p>It is not uncommon to have some optional fields in the message, the existence
of which depends on some bits in previous fields. In this case the default
read and/or write behaviour generated by the compiler needs to be modified.
Thanks to the inheritance relationship between the classes, nothing prevents us
from overriding the <code>readImpl()</code> and/or <code>writeImpl()</code> function and providing the
right behaviour:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span> <span class="p">{...}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeImpl</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{...}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MessageBase&lt;&#8230;&#8203;&gt;</code> class already contains the definition of <code>FieldReader</code> and
<code>FieldWriter</code> helper classes, it can provide helper functions to read/write only
several fields from the whole bundle. These functions can be reused in the
overriding implementations of <code>readImpl()</code> and/or <code>writeImpl()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TFromIdx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TUntilIdx</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">readFieldsFromUntil</span><span class="p">(</span>
        <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEachFromUntil</span><span class="o">&lt;</span><span class="n">TFromIdx</span><span class="p">,</span> <span class="n">TUntilIdx</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldReader</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TFromIdx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TUntilIdx</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">writeFieldsFromUntil</span><span class="p">(</span>
        <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
        <span class="n">tupleForEachFromUntil</span><span class="o">&lt;</span><span class="n">TFromIdx</span><span class="p">,</span> <span class="n">TUntilIdx</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">m_fields</span><span class="p">,</span> <span class="n">FieldWriter</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">FieldReader</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
    <span class="k">class</span> <span class="nc">FieldWriter</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

    <span class="n">AllFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The provided <code>readFieldsFromUntil()</code> and <code>writeFieldsFromUntil()</code> protected member
functions use <code>tupleForEachFromUntil()</code> function to perform read/write operations
on a group of selected fields. It is similar to <code>tupleForEach()</code> used earlier, but
receives additional template parameters, that specify indices of the fields for
which the provided functor object needs to be invoked. The code of
<code>tupleForEachFromUntil()</code> function can be found in <a href="#appendix-c">Appendix C - tupleForEachFromUntil</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fields-access">Working With Fields</h3>
<div class="paragraph">
<p>In order to <a href="#fields-automation">automate</a> some basic operations, all the fields
had to provide the same basic interface. As the result the actual field values
had to be wrapped in a class that defines the required public interface.
Such class must also provide means to access/update the wrapped value.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Value storage type definition</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Provide an access to the stored value</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume the <code>ActualMessage1</code> defines 3 integer value fields with
serialisation lengths of 1, 2, and 4 bytes respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span><span class="o">&gt;</span>
    <span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span><span class="o">&gt;</span>
<span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MessageBase</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&gt;</span> <span class="p">{...};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#message-dispatch_handle">Dispatching and Handling</a> chapter described
the efficient way to dispatch message object to its handler. The appropriate
handling function may access its field&#8217;s value using the following code
flow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Handler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage1</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Get access to the field's bundle of type std::tuple</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">allFields</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">fields</span><span class="p">();</span>

        <span class="c1">// Get access to the field abstractions.</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">field1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">field2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">field3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>

        <span class="c1">// Get access to the values themselves:</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">field1</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">int16_t</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">field2</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">field3</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>

        <span class="p">...</span> <span class="n">Do</span> <span class="n">something</span> <span class="n">with</span> <span class="n">retrieved</span> <span class="n">values</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When preparing message to send, the similar code sequence may be applied to
update the values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">ActualMessage1</span> <span class="n">msg</span><span class="p">;</span>

<span class="c1">// Get access to the field's bundle of type std::tuple</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">allFields</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">fields</span><span class="p">();</span>

<span class="c1">// Get access to the field abstractions.</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">field1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">field2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">field3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allFields</span><span class="p">);</span>

<span class="c1">// Update the values themselves:</span>
<span class="n">field1</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">field2</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">field3</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="p">...;</span>

<span class="c1">// Serialise and send the message:</span>
<span class="n">sendMessage</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fields-common_types">Common Field Types</h3>
<div class="paragraph">
<p>The majority of communication protocols use relatively small set of various
field types. However, the number of various ways used to serialise these fields,
as well as handle them in different parts of the code, may be significantly bigger.</p>
</div>
<div class="paragraph">
<p>It would be impractical to create a separate class for each and every variant
of the same type fields. That&#8217;s why there is a need to use template parameters
when defining a frequently used field type. The basic example would be implementing
<strong>numeric integral value</strong> fields. Different fields of such type may have
different serialisation lengths.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TValueType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IntValueField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="n">TValueType</span><span class="p">;</span>

    <span class="c1">// Accessed stored value</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{...</span> <span class="cm">/* read m_value */</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="p">{...</span> <span class="cm">/* write m_value */</span> <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is a description of most common fields used by majority of
binary communication protocols with the list of possible variations, that can
influence how the field is serialised and/or handled.</p>
</div>
<div class="paragraph">
<p>The <a href="#library-library">Generic Library</a> chapter will
concentrate on how to generalise development of any communication protocol by
creating a generic library and reusing it in independent implementations of
various protocols. It will also explain how to create generic field
classes for the types listed below.</p>
</div>
<div class="sect3">
<h4 id="fields-common_types-numeric_integral">Numeric Integral Values</h4>
<div class="paragraph">
<p>Used to operate with simple numeric integer values.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>May have different serialisation length: 1, 2, 3, 4, 5, &#8230;&#8203; bytes. Having
basic types of <code>std::uint8_t</code>, <code>std::uint16_t</code>, <code>std::uint32_t</code>, &#8230;&#8203; may be
not enough. Some extra work may be required to support lengths, such as 3, 5, 6,
7 bytes.</p>
</li>
<li>
<p>May be signed and unsigned. Some protocols require different serialisation rules
for signed values, such as adding some predefined offset prior
to serialisation to make sure that the value being serialised is non-negative. When
value deserialised, the same offset must be subtracted to get the actual value.</p>
</li>
<li>
<p>May have variable serialisation length, based on the value being serialised,
such as having <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Base-128</a>
encoding.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="fields-common_types-enum">Enumeration Values</h4>
<div class="paragraph">
<p>Similar to <a href="#fields-common_types-numeric_integral">Numeric Integral Values</a>, but storing
the value as enumeration type for easier access.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields-common_types-bitmask">Bitmask Values</h4>
<div class="paragraph">
<p>Similar to <a href="#fields-common_types-numeric_integral">Numeric Integral Values</a>, but with
<strong>unsigned</strong> internal storage type and with each bit having separate meaning.
The class definition should support having different serialisation lengths as
well as provide a convenient interface to inquire about and update various bits'
values.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields-common_types-strings">Strings</h4>
<div class="paragraph">
<p>Some protocols serialise strings by prefixing the string itself with its size,
others have <code>'\0'</code> suffix to mark the end of the string.
Some strings may be allocated a fixed size and require
<code>'\0'</code> padding if its actual length is shorter.</p>
</div>
<div class="paragraph">
<p>Consider how the internal string value is stored. Usually <code>std::string</code> is used.
However, what about the bare-metal embedded systems, that disallow usage of
dynamic memory allocation and/or exceptions? There needs to be a way to substitute
underlying <code>std::string</code> with a custom implementation of some <code>StaticString</code>
that exposes similar interface, but receives a maximum storage size as a template
parameter.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields-common_types-lists">Lists</h4>
<div class="paragraph">
<p>There may be lists of raw bytes, list of other fields, or even a group of fields.
Similar to <a href="#fields-common_types-strings">Strings</a>, the serialisation of lists may differ. Lists of
variable size may require a prefix with their size information. Other lists
may have fixed (predefined) size and will not require any additional size
information.</p>
</div>
<div class="paragraph">
<p>The internal storage consideration is applicable here as well. For most systems
<code>std::vector</code> will do the job, but for bare-metal ones something else may be
required. For example some custom implementation of <code>StaticVector</code> that exposes
the same public interface, but receives a maximum storage size as a template parameter.
There must be an easy way to substitute one with another.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields-common_types-bundles">Bundles</h4>
<div class="paragraph">
<p>The group of fields sometimes needs to be bundled into a single entity and
be treated as a single field. The good example would be having a <a href="#fields-common_types-lists">list</a>
of complex structures (bundles).</p>
</div>
</div>
<div class="sect3">
<h4 id="_bitfields">Bitfields</h4>
<div class="paragraph">
<p>Similar to <a href="#fields-common_types-bundles">Bundles</a>, where every field member takes only limited
number of bits instead of bytes. Usually the members of the bitfields are
<a href="#fields-common_types-numeric_integral">Numeric Integral Values</a>,
<a href="#fields-common_types-enum">Enumeration Values</a>, and <a href="#fields-common_types-bitmask">Bitmask Values</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_common_variations">Common Variations</h4>
<div class="paragraph">
<p>All the fields stated above may require an ability to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>set custom default value when the field object is created.</p>
</li>
<li>
<p>have custom value validation logic.</p>
</li>
<li>
<p>fail the read operation on invalid value.</p>
</li>
<li>
<p>ignore the incoming invalid value, i.e. not to fail the read operation, but
preserve the existing value if the value being read is invalid.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="library-library">Generic Library</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All the generalisation techniques, described so far, are applicable to most
binary communication protocols. It is time to think about something generic -
a library that can be reused between independent projects and facilitate a
development of any binary communication protocol.</p>
</div>
<div class="paragraph">
<p>From now on, every generic, protocol independent class and/or function
is going to reside in <code>comms</code> namespace in order to differentiate it from a
protocol specific code.</p>
</div>
<div class="sect2">
<h3 id="library-interface">Generalising Message Interface</h3>
<div class="paragraph">
<p>The basic generic message interface may include the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Retrieve the message ID.</p>
</li>
<li>
<p>Read (deserialise) the message contents from raw data in a buffer.</p>
</li>
<li>
<p>Write (serialise) the message contents into a buffer.</p>
</li>
<li>
<p>Calculate the serialisation length of the message.</p>
</li>
<li>
<p>Dispatch the message to an appropriate handling function.</p>
</li>
<li>
<p>Check the validity of the message contents.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There may be multiple cases when not all of the operations stated above are
needed for some specific case. For example, some sensor only reports its
internal data to the outside world over some I/O link, and doesn&#8217;t listen to
the incoming messages. In this case the <code>read()</code> operation is redundant and
its implementation should not take space in the produced binary code.
However, the component that resides on the other end of the I/O link requires
the opposite functionality, it only consumes data, without producing anything,
i.e. <code>write()</code> operation becomes unnecessary.</p>
</div>
<div class="paragraph">
<p>There must be a way to limit the basic interface to a particular set of
functions, when needed.</p>
</div>
<div class="paragraph">
<p>Also there must be a way to specify:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>type used to store and report the message ID.</p>
</li>
<li>
<p>type of the read/write iterators</p>
</li>
<li>
<p>endian used in data serialisation.</p>
</li>
<li>
<p>type of the message handling class, which is used in <code>dispatch()</code> functionality.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The best way to support such variety of requirements is to use the
<a href="http://en.cppreference.com/w/cpp/language/parameter_pack">variadic templates</a>
feature of C&#43;&#43;11, which allows having non-fixed number of template parameters.</p>
</div>
<div class="paragraph">
<p>These parameters have to be parsed and used to define all the required
internal functions and types. The common message interface class is expected
to be defined like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>TOptions</code> is a set of classes/structs, which can be used to define all the
required types and functionalities.</p>
</div>
<div class="paragraph">
<p>Below is an example of such possible option classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="c1">// Define type used to store message ID</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MsgIdType</span><span class="p">{};</span>

<span class="c1">// Specify type of iterator used for reading</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ReadIterator</span> <span class="p">{};</span>

<span class="c1">// Specify type of iterator used for writing</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">WriteIterator</span> <span class="p">{};</span>

<span class="c1">// Use little endian for serialisation (instead of default big)</span>
<span class="k">struct</span> <span class="n">LittleEndian</span> <span class="p">{};</span>

<span class="c1">// Include serialisation length retrieval in public interface</span>
<span class="k">struct</span> <span class="n">LengthInfoInterface</span> <span class="p">{};</span>

<span class="c1">// Include validity check in public interface</span>
<span class="k">struct</span> <span class="n">ValidCheckInterface</span> <span class="p">{};</span>

<span class="c1">// Define handler class</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Handler</span><span class="p">{};</span>
<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Our <strong>PRIMARY OBJECTIVE</strong> for this chapter is to provide an ability to
create a common message interface class with only requested functionality.</p>
</div>
<div class="paragraph">
<p>For example, the definition of <code>MyMessage</code> interface class below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyHandler</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MyMessage</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Message</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// use std::uint16_t as message ID type</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">,</span> <span class="c1">// use const std::uint8_t* as iterator for reading</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">WriteIterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">,</span> <span class="c1">// use std::uint8_t* as iterator for writing</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LengthInfoInterface</span><span class="p">,</span> <span class="c1">// add length() member function to interface</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">Handler</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span> <span class="c1">// add dispatch() member function with MyHandler as the handler class</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>should be equivalent to defining:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyMessage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Handler</span> <span class="o">=</span> <span class="n">MyHandler</span><span class="p">;</span>

    <span class="n">MsgIdType</span> <span class="n">id</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="p">{...}</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span> <span class="p">{...}</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// use big endian by default</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>  <span class="c1">// use big endian by default</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following definition of <code>MyMessage</code> interface class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyMessage</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Message</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// use std::uint8_t as message ID type</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LittleEndian</span><span class="p">,</span> <span class="c1">// use little endian in serialisation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span> <span class="c1">// use const std::uint8_t* as iterator for reading</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>will be equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyMessage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>

    <span class="n">MsgIdType</span> <span class="n">id</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// use little endian</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>  <span class="c1">// use little endian</span>

    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks nice, isn&#8217;t it? So, how are we going to achieve this? Any ideas?</p>
</div>
<div class="paragraph">
<p>That&#8217;s right! We use <strong>MAGIC</strong>!</p>
</div>
<div class="paragraph">
<p>Sorry, I mean template meta-programming. Let&#8217;s get started!</p>
</div>
<div class="sect3">
<h4 id="_parsing_the_options">Parsing the Options</h4>
<div class="paragraph">
<p>First thing, that needs to be done, is to parse the provided options and record
them in some kind of a summary structure, with predefined list of
<code>static const bool</code> variables, which indicate what options have been used,
such as one below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasMsgIdType</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLittleEndian</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasReadIterator</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasWriteIterator</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasHandler</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasValid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLength</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If some variable is set to <code>true</code>, the <strong>summary structure</strong> may also contain
some additional relevant types and/or more variables.</p>
</div>
<div class="paragraph">
<p>For example the definition of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyHandler</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MyMessage</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Message</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// use std::uint16_t</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">,</span> <span class="c1">// use const std::uint8_t* as iterator for reading</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">WriteIterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">,</span> <span class="c1">// use std::uint8_t* as iterator for writing</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LengthInfoInterface</span><span class="p">,</span> <span class="c1">// add length() member function to interface</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">Handler</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span> <span class="c1">// add dispatch() member function with MyHandler as the handler class</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>should result in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasMsgIdType</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLittleEndian</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasReadIterator</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasWriteIterator</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasHandler</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasValid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLength</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Handler</span> <span class="o">=</span> <span class="n">MyHandler</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here goes the actual code.</p>
</div>
<div class="paragraph">
<p>First, there is a need to define an initial version of such summary structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageInterfaceParsedOptions</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasMsgIdType</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLittleEndian</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasReadIterator</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasWriteIterator</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasHandler</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasValid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLength</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, handle the provided options one by one, while replacing the initial values
and defining additional types when needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
                                        <span class="k">public</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasMsgIdType</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LittleEndian</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
                                        <span class="k">public</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasLittleEndian</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
                                        <span class="k">public</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasReadIterator</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span> <span class="c1">// and so on</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that inheritance relationship is used, and according to the C&#43;&#43; language specification
the new variables with the same name hide (or replace) the variables defined in
the base class.</p>
</div>
<div class="paragraph">
<p>Also note, that the order of the options being used to define the interface
class does NOT really matter. However, it is recommended, to add some
<code>static_assert()</code> statements in, to make sure the same options are not used twice,
or no contradictory ones are used together (if such exist).</p>
</div>
</div>
<div class="sect3">
<h4 id="_assemble_the_required_interface">Assemble the Required Interface</h4>
<div class="paragraph">
<p>The next stage in the <strong>defining message interface</strong> process is to define
various chunks of interface functionality and connect them via inheritance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// ID retrieval chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TId</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageInterfaceIdTypeBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="n">TId</span><span class="p">;</span>
    <span class="n">MsgIdType</span> <span class="n">getId</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">getIdImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">MsgIdType</span> <span class="n">getIdImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Big endian serialisation chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageInterfaceBigEndian</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// use big endian</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>  <span class="c1">// use big endian</span>
<span class="p">};</span>

<span class="c1">// Little endian serialisation chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageInterfaceLittleEndian</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span> <span class="c1">// use little endian</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>  <span class="c1">// use little endian</span>
<span class="p">};</span>

<span class="c1">// Read functionality chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TReadIter</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageInterfaceReadBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="n">TReadIter</span><span class="p">;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span> <span class="c1">// and so on</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that the interface chunks receive their base class through template
parameters. It will allow us to connect them together using inheritance. Together
they can create the required custom interface.</p>
</div>
<div class="paragraph">
<p>There is a need for some extra helper classes to implement such connection
logic which chooses only requested chunks and skips the others.</p>
</div>
<div class="paragraph">
<p>The code below chooses whether to add <code>MessageInterfaceIdTypeBase</code> into
the inheritance chain of interface chunks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasMsgIdType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessMsgId</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessMsgId</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageInterfaceIdTypeBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessMsgId</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that the interface options were parsed and typedef-ed into some
<code>ParsedOptions</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then after the following definition statement</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">NewBaseClass</span> <span class="o">=</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageInterfaceProcessMsgId</span><span class="o">&lt;</span>
        <span class="n">OldBaseClass</span><span class="p">,</span>
        <span class="n">ParsedOptions</span><span class="p">,</span>
        <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasMsgIdType</span>
    <span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>the <code>NewBaseClass</code> is the same as <code>OldBaseClass</code>, if the value of
<code>ParsedOptions::HasMsgIdType</code> is <code>false</code> (type of message ID wasn&#8217;t provided
via options), otherwise <code>NewBaseClass</code> becomes
<code>comms::MessageInterfaceIdTypeBase</code>, which inherits from <code>OldBaseClass</code>.</p>
</div>
<div class="paragraph">
<p>Using the same pattern the other helper wrapping classes must be implemented
also.</p>
</div>
<div class="paragraph">
<p>Choose right chunk for endian:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasLittleEndian</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessEndian</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessEndian</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageInterfaceLittleEndian</span><span class="o">&lt;</span><span class="n">TBase</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessEndian</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageInterfaceBigEndian</span><span class="o">&lt;</span><span class="n">TBase</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Add read functionality if required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasReadIterator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessReadIterator</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessReadIterator</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageInterfaceReadBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TParsedOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessReadIterator</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TParsedOptions</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The interface building code just uses the helper classes in a sequence of
type definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">EmptyBase</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceBuilder</span>
<span class="p">{</span>
    <span class="c1">// Parse the options</span>
    <span class="k">using</span> <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="n">MessageInterfaceParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// Add ID retrieval functionality if ID type was provided</span>
    <span class="k">using</span> <span class="n">Base1</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageInterfaceProcessMsgId</span><span class="o">&lt;</span>
            <span class="n">EmptyBase</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasMsgIdType</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Add readData() and writeData(), that use the right endian</span>
    <span class="k">using</span> <span class="n">Base2</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageInterfaceProcessEndian</span><span class="o">&lt;</span>
            <span class="n">Base1</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasLittleEndian</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Add read functionality if ReadIterator type was provided</span>
    <span class="k">using</span> <span class="n">Base3</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageInterfaceProcessReadIterator</span><span class="o">&lt;</span>
            <span class="n">Base2</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasReadIterator</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Add write functionality if WriteIterator type was provided</span>
    <span class="k">using</span> <span class="n">Base4</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageInterfaceProcessWriteIterator</span><span class="o">&lt;</span>
            <span class="n">Base3</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasWriteIterator</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// And so on...</span>
    <span class="p">...</span>
    <span class="k">using</span> <span class="n">BaseN</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// The last BaseN must be taken as final type.</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">BaseN</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once all the required definitions are in place, the common dynamic message
interface class <code>comms::Message</code> may be defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">:</span> <span class="k">public</span> <span class="k">typename</span> <span class="n">MessageInterfaceBuilder</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span>
<span class="p">{</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the result, any distinct set of options provided as the template parameters
to <code>comms::Message</code> class will cause it to have the required types and
member functions.</p>
</div>
<div class="paragraph">
<p>Now, when the interface is in place, it is time to think about providing
common <code>comms::MessageBase</code> class which is responsible to provide
default implementation for functions, such as <code>readImpl()</code>, <code>writeImpl()</code>,
<code>dispatchImpl()</code>, etc&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="library-impl">Generalising Message Implementation</h3>
<div class="paragraph">
<p>Previous chapters described <code>MessageBase</code> class, which provided implementation for
some portions of polymorphic behaviour defined in the interface class <code>Message</code>.
Such implementation eliminated common boilerplate code used in every <code>ActualMessage*</code>
class.</p>
</div>
<div class="paragraph">
<p>This chapter is going to generalise the implementation of <code>MessageBase</code> into
the generic <code>comms::MessageBase</code> class, which is communication protocol independent
and can be re-used in any other development.</p>
</div>
<div class="paragraph">
<p>The generic <code>comms::MessageBase</code> class must be able to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>provide the ID of the message, i.e. implement the <code>idImpl()</code>
virtual member function, when such ID is known at compile time.</p>
</li>
<li>
<p>provide common dispatch functionality, i.e. implement <code>dispatchImpl()</code>
virtual member function, described in
<a href="#message-dispatch_handle">Dispatching and Handling</a> chapter.</p>
</li>
<li>
<p>support extension of the default message interface, described in
<a href="#message-extend_interface">Extending Interface</a> chapter.</p>
</li>
<li>
<p>automate common operations on fields, i.e. implement <code>readImpl()</code>, <code>writeImpl()</code>,
<code>lengthImpl()</code>, etc&#8230;&#8203;, described in <a href="#fields-automation">Automating Basic Operations</a> chapter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just like common <code>comms::Message</code> interface class, the <code>comms::MessageBase</code>
will also receive options to define its behaviour.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that the <code>comms::MessageBase</code> class receives its base class as a
template parameter. It is expected to be any variant of <code>comms::Message</code> or
any extended interface class, which inherits from <code>comms::Message</code>.</p>
</div>
<div class="paragraph">
<p>The supported options may include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="c1">// Provide static numeric ID, to facilitate implementation of idImpl()</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TId</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StaticNumIdImpl</span> <span class="p">{};</span>

<span class="c1">// Facilitate implementation of dispatchImpl()</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TActual</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">DispatchImpl</span> <span class="p">{};</span>

<span class="c1">// Provide fields of the message, facilitate implementation of</span>
<span class="c1">// readImpl(), writeImpl(), lengthImpl(), validImpl(), etc...</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldsImpl</span> <span class="p">{};</span>

<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_parsing_the_options_2">Parsing the Options</h4>
<div class="paragraph">
<p>The options provided to the <code>comm::MessageBase</code> class need to be parsed in a
very similar way as it was with <code>comms::Message</code> in the previous chapter.</p>
</div>
<div class="paragraph">
<p>Starting with initial version of the options struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageImplParsedOptions</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasStaticNumIdImpl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasDispatchImpl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFieldsImpl</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and replacing the initial value of the appropriate variable with new ones, when
appropriate option is discovered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TId</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">StaticNumIdImpl</span><span class="o">&lt;</span><span class="n">TId</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
        <span class="k">public</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasStaticNumIdImpl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">MsgId</span> <span class="o">=</span> <span class="n">TID</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TActual</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">DispatchImpl</span><span class="o">&lt;</span><span class="n">TActual</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
        <span class="k">public</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasDispatchImpl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ActualMessage</span> <span class="o">=</span> <span class="n">TActual</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFields</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">TFields</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
        <span class="k">public</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFieldsImpl</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Fields</span> <span class="o">=</span> <span class="n">TFields</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_assemble_the_required_implementation">Assemble the Required Implementation</h4>
<div class="paragraph">
<p>Just like with building custom message interface, there is a need to
create chunks of implementation parts and connect them using inheritance
based on used options.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// ID information chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TId</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageImplStaticNumIdBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Reuse the message ID type defined in the interface</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Base</span><span class="o">::</span><span class="n">MsgIdType</span><span class="p">;</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">MsgIdType</span> <span class="n">getIdImpl</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MsgIdType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TId</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Dispatch implementation chunk</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TActual</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageImplDispatchBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Reuse the Handler type defined in the interface class</span>
    <span class="k">using</span> <span class="n">Handler</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Base</span><span class="o">::</span><span class="n">Handler</span><span class="p">;</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispatchImpl</span><span class="p">(</span><span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TActual</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that single option <code>comms::option::FieldsImpl&lt;&gt;</code> may facilitate
implementation of multiple functions: <code>readImpl()</code>, <code>writeImpl()</code>, <code>lengthImpl()</code>,
etc&#8230;&#8203; Every such function was declared due to using a separate option when
defining the interface. We&#8217;ll have to cherry-pick appropriate implementation
parts, based on the interface options. As the result, these implementation
chunks must be split into separate classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFields</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageImplFieldsBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">AllFields</span> <span class="o">=</span> <span class="n">TFields</span><span class="p">;</span>

    <span class="n">AllFields</span><span class="o">&amp;</span> <span class="n">fields</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_fields</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">AllFields</span><span class="o">&amp;</span> <span class="n">fields</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_fields</span><span class="p">;</span> <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">TFields</span> <span class="n">m_fields</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">NessageImplFieldsReadBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Reuse ReadIterator definition from interface class</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TBase</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">ErrorStatus</span> <span class="n">readImpl</span><span class="p">(</span><span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="c1">// Access fields via interface provided in previous chunk</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">allFields</span> <span class="o">=</span> <span class="n">TBase</span><span class="o">::</span><span class="n">fields</span><span class="p">();</span>
        <span class="p">...</span> <span class="c1">// read all the fields</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span> <span class="c1">// and so on</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>All these implementation chunks are connected together using extra helper classes
in a very similar way to how the interface chunks where connected:</p>
</div>
<div class="paragraph">
<p>Add <code>idImpl()</code> if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">TImplement</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessStaticNumId</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessStaticNumId</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageImplStaticNumIdBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">ParsedImplOptions</span><span class="o">::</span><span class="n">MsgId</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageInterfaceProcessEndian</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Add <code>dispatchImpl()</code> if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">TImplement</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessDispatch</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessDispatch</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageImplDispatchBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">::</span><span class="n">ActualMessage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessDispatch</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Add <code>fields()</code> access if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">TImplement</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessFields</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessFields</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">ParsedImplOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">MessageImplFieldsBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">::</span><span class="n">Fields</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ParsedImplOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessFields</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Add <code>readImpl()</code> if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">TImplement</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessReadFields</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessReadFields</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">NessageImplFieldsReadBase</span><span class="o">&lt;</span><span class="n">TBase</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplProcessReadFields</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on for all the required implementation chunks: <code>writeImpl()</code>, <code>lengthImpl()</code>,
<code>validImpl()</code>, etc&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The final stage is to connect all the implementation chunks together
via inheritance and derive <code>comms::MessageBase</code> class from the result.</p>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that existence of the implementation chunk depends not only on the
implementation options provided to <code>comms::MessageBase</code>, but also on the
interface options provided to <code>comms::Message</code>. For example, <code>writeImpl()</code> must
be added only if <code>comms::Message</code> interface includes <code>write()</code> member function
(<code>comms::option::WriteIterator&lt;&gt;</code> option was used) and implementation option
which adds support for fields (<code>comms::option::FieldsImpl&lt;&gt;</code>) was passed to
<code>comms::MessageBase</code>.</p>
</div>
<div class="paragraph">
<p>The implementation builder helper class looks as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TBase is interface class</span>
<span class="c1">// TOptions... are the implementation options</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">MessageImplBuilder</span>
<span class="p">{</span>
    <span class="c1">// ParsedOptions class is supposed to be defined in comms::Message class</span>
    <span class="k">using</span> <span class="n">InterfaceOptions</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TBase</span><span class="o">::</span><span class="n">ParsedOptions</span><span class="p">;</span>

    <span class="c1">// Parse implementation options</span>
    <span class="k">using</span> <span class="n">ImplOptions</span> <span class="o">=</span> <span class="n">MessageImplParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// Provide idImpl() if possible</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasStaticNumIdImpl</span> <span class="o">=</span>
        <span class="n">InterfaceOptions</span><span class="o">::</span><span class="n">HasMsgIdType</span> <span class="o">&amp;&amp;</span> <span class="n">ImplOptions</span><span class="o">::</span><span class="n">HasStaticNumIdImpl</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base1</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageImplProcessStaticNumId</span><span class="o">&lt;</span>
            <span class="n">TBase</span><span class="p">,</span> <span class="n">ImplOptions</span><span class="p">,</span> <span class="n">HasStaticNumIdImpl</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Provide dispatchImpl() if possible</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasDispatchImpl</span> <span class="o">=</span>
        <span class="n">InterfaceOptions</span><span class="o">::</span><span class="n">HasHandler</span> <span class="o">&amp;&amp;</span> <span class="n">ImplOptions</span><span class="o">::</span><span class="n">HasDispatchImpl</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base2</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageImplProcessDispatch</span><span class="o">&lt;</span>
            <span class="n">Base1</span><span class="p">,</span> <span class="n">ImplOptions</span><span class="p">,</span> <span class="n">HasDispatchImpl</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Provide access to fields if possible</span>
    <span class="k">using</span> <span class="n">Base3</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageImplProcessFields</span><span class="o">&lt;</span>
            <span class="n">Base2</span><span class="p">,</span> <span class="n">ImplOptions</span><span class="p">,</span> <span class="n">ImplOptions</span><span class="o">::</span><span class="n">HasFieldsImpl</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Provide readImpl() if possible</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasReadImpl</span> <span class="o">=</span>
        <span class="n">InterfaceOptions</span><span class="o">::</span><span class="n">HasReadIterator</span> <span class="o">&amp;&amp;</span> <span class="n">ImplOptions</span><span class="o">::</span><span class="n">HasFieldsImpl</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Base4</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageImplProcessReadFields</span><span class="o">&lt;</span>
            <span class="n">Base3</span><span class="p">,</span> <span class="n">HasReadImpl</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// And so on...</span>
    <span class="p">...</span>
    <span class="k">using</span> <span class="n">BaseN</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// The last BaseN must be taken as final type.</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">BaseN</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Defining the generic <code>comms::MessageBase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MessageBase</span> <span class="o">:</span> <span class="k">public</span> <span class="k">typename</span> <span class="n">MessageImplBuilder</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TOptions</span><span class="o">&gt;::</span><span class="n">Type</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that <code>TBase</code> template parameter is passed to <code>MessageImplBuilder&lt;&gt;</code>,
which in turn passes it up the chain of possible implementation chunks, and
at the end it turns up to be the base class of the whole hierarchy.</p>
</div>
<div class="paragraph">
<p>The full hierarchy of classes presented at the image below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/library_full_hierarchy.png" alt="Image: Full class hierarchy">
</div>
</div>
<div class="paragraph">
<p>The total number of used classes may seem scary, but there are only two, which
are of any particular interest to us when implementing communication protocol.
It&#8217;s <code>comms::Message</code> to specify the interface and <code>comms::MessageBase</code> to
provide default implementation of particular functions. All the rest are just
implementation details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_summary">Summary</h4>
<div class="paragraph">
<p>After all this work our library contains generic <code>comms::Message</code> class, that
defines the interface, as well as generic <code>comms::MessageBase</code> class, that provides
default implementation for required polymorphic functionality.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s define a custom communication protocol which uses little endian
for data serialisation and has numeric
message ID type defined with the enumeration below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">MyMsgId</span>
<span class="p">{</span>
    <span class="n">MyMsgId_Msg1</span><span class="p">,</span>
    <span class="n">MyMsgId_Msg2</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming we have relevant field classes in place (see <a href="#fields-fields">Fields</a>
chapter), let&#8217;s define custom <code>ActualMessage1</code> that contains two integer
value fields: 2 bytes unsigned value and 1 byte signed value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int8_t</span><span class="o">&gt;</span>
<span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessageInterface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">StaticNumIdImpl</span><span class="o">&lt;</span><span class="n">MyMsgId_Msg1</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// provide idImpl() if needed</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">DispatchImpl</span><span class="o">&lt;</span><span class="n">ActualMessage1</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// provide dispatchImpl() if needed</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&gt;</span> <span class="c1">// provide access to fields and</span>
                                                        <span class="c1">// readImpl(), writeImpl(),</span>
                                                        <span class="c1">// lengthImpl(), validImpl()</span>
                                                        <span class="c1">// functions if needed</span>
    <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it, no extra member functions are needed to be implemented, unless the
message interface class is <a href="#message-extend_interface">Extending Interface</a>.
Note, that the implementation of the <code>ActualMessage1</code> is completely generic
and doesn&#8217;t depend on the actual message interface. It can be reused in any
application with any runtime environment that uses our custom protocol.</p>
</div>
<div class="paragraph">
<p>The interface class is defined according to the requirements of the application, that
uses the implementation of the defined protocol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyHandler</span><span class="p">;</span> <span class="c1">// forward declaration of the handler class.</span>
<span class="k">using</span> <span class="n">MyMessage</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Message</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">MyMsgId</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// add id() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">,</span> <span class="c1">// add read() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">WriteIterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span> <span class="c1">// add write() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">Handler</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// add dispatch() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LengthInfoInterface</span><span class="p">,</span> <span class="c1">// add length() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ValidCheckInterface</span><span class="p">,</span> <span class="c1">// add valid() operation</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LittleEndian</span> <span class="c1">// use little endian for serialisation</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience the protocol messages should be redefined with appropriate
interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyActualMessage1</span> <span class="o">=</span> <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">MyMessage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MyActualMessage2</span> <span class="o">=</span> <span class="n">ActualMessage2</span><span class="o">&lt;</span><span class="n">MyMessage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">...</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="library-fields">Generalising Fields Implementation</h3>
<div class="paragraph">
<p>The <a href="#fields-automation">automation</a> of read/write operations of the message
required fields to expose predefined minimal interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SomeField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Value storage type definition</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Provide an access to the stored value</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Read (deserialise) and update internal value</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

    <span class="c1">// Write (serialise) internal value</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Get the serialisation length</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The read/write operations will probably require knowledge about the serialisation
endian used for the protocol. We need to come up
with the way to convey the endian information to the field classes. I would recommend
doing it by having common base class for all the fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">THasLittleEndian</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Field</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="c1">// Read value using appropriate endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Read partial value using appropriate endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Write value using appropriate endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Write partial value using appropriate endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">writeData</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The choice of the right endian may be implemented using
<a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">Tag Dispatch Idiom</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">THasLittleEndian</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Field</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="c1">// Read value using appropriate endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readData</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Dispatch to appropriate read function</span>
        <span class="k">return</span> <span class="n">readDataInternal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">Tag</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">BigEndianTag</span> <span class="p">{};</span>
    <span class="n">LittleEndianTag</span> <span class="p">{};</span>

    <span class="k">using</span> <span class="n">Tag</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
        <span class="n">THasLittleEndian</span><span class="p">,</span>
        <span class="n">LittleEndianTag</span><span class="p">,</span>
        <span class="n">BigEndianTag</span>
    <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

    <span class="c1">// Read value using big endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readBig</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Read value using little endian</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readLittle</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Dispatch to readBig()</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readDataInternal</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">BigEndianTag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">readBig</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Dispatch to readLittle()</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">readDataInternal</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">LittleEndianTag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">readLittle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Every field class should receive its base class as a template parameter and
may use available <code>readData()</code> and <code>writeData()</code> static member functions
when serialising/deserialising internal value in <code>read()</code> and <code>write()</code>
member functions.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValueType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IntValueField</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TBase</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="n">TBase</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="n">TValueType</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">NotEnoughData</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_value</span> <span class="o">=</span> <span class="n">Base</span><span class="o">::</span><span class="k">template</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">BufferOverflow</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Base</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">m_value</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ValueType</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the endian is known and fixed (for example when implementing third party
protocol according to provided specifications), and there is little chance it&#8217;s ever going
to change, the base class for all the fields may be explicitly defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyProjField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// Use big endian for fields serialisation</span>
<span class="k">using</span> <span class="n">MyIntField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">MyProjField</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there may be the case when the endian information is not known up
front, and the one provided to the message interface definition (<code>comms::Message</code>)
must be used. In this case, the message interface class may define common
base class for all the fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">:</span> <span class="k">public</span> <span class="k">typename</span> <span class="n">MessageInterfaceBuilder</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">MessageInterfaceBuilder</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>
<span class="nl">pablic:</span>
    <span class="k">using</span> <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Base</span><span class="o">::</span><span class="n">ParsedOptions</span> <span class="p">;</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasLittleEndian</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the result the definition of the message&#8217;s fields must receive a template
parameter of the base class for all the fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFieldBase</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">TFieldBase</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">TFieldBase</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;:</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="o">::</span><span class="n">Field</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span>
        <span class="p">...</span>
    <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_ways_to_serialise_fields">Multiple Ways to Serialise Fields</h4>
<div class="paragraph">
<p>The <a href="#fields-common_types">Common Field Types</a> chapter described most
common types of fields with various serialisation and handling nuances,
which can be used to implement a custom communication protocol.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the basic integer value field as an example. The most common way
to serialise it is just read/write its internally stored value as is. However,
there may be cases when serialisation takes limited number of bytes. Let&#8217;s say,
the protocol specification states that some integer value consumes only 3 bytes
in the serialised bytes sequence. In this case the value will probably be be
stored using <code>std::int32_t</code> or <code>std::uint32_t</code> type. The field class will also
require different implementation of read/write/length functionality.</p>
</div>
<div class="paragraph">
<p>Another possible case is a necessity to add/subtract some predefined offset to/from the value
being serialised and subtracting/adding the same offset when the value is deserialised.
Good example of such case would be the serialisation of a <strong>year</strong> information,
which is serialised as an offset from year 2000 and consumes only 1 byte.
It is possible to store the value as a single byte
(<code>comms::IntValueField&lt;&#8230;&#8203;, std::uint8_t&gt;</code>), but it would be very inconvenient.
It is much better if we could store a normal year value (<code>2015</code>, <code>2016</code>, etc &#8230;&#8203;)
using <code>std::uint16_t</code> type, but when serialising, the values that get written
are <code>15</code>, <code>16</code>, etc&#8230;&#8203; <strong>NOTE</strong>, that such field requires two steps in its
serialisation logic:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>add required offset (<code>-2000</code> in the example above)</p>
</li>
<li>
<p>limit the number of bytes when serialising the result</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Another popular way to serialise integer value is to use
<a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Base-128</a>
encoding. In this case the number of bytes in the serialisation sequence is
not fixed.</p>
</div>
<div class="paragraph">
<p>What if some protocol decides to serialise the same offset from
year 2000, but using the <strong>Base-128</strong> encoding? It becomes obvious that
having a separate field class for every possible variant is impractical at
least. There must be a way to split the serialisation logic into small
chunks, which can be applied one on top of another.</p>
</div>
<div class="paragraph">
<p>Using the same idea of the <em>options</em> and adapting the behaviour of the field
class accordingly, we can generalise all the <a href="#fields-fields">fields</a>
into a small subset of classes and make them also part of
our generic library.</p>
</div>
<div class="paragraph">
<p>The options described earlier may be defined using following option classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="c1">// Provide fixed serialisation length</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TLen</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FixedLength</span> <span class="p">{};</span>

<span class="c1">// Provide numeric offset to be added to the value before serialisation</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TOffset</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">NumValueSerOffset</span> <span class="p">{};</span>

<span class="c1">// Force using variable length (base-128 encoding) while providing</span>
<span class="c1">// minimal and maximal allowed serialisation lengths.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TMin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TMax</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">VarLength</span> <span class="p">{};</span>

<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parsing_the_options_3">Parsing the Options</h4>
<div class="paragraph">
<p>In a very similar way to parsing options of the message interface (<code>comms::Message</code>)
and message implementation (<code>comms::MessageBase</code>) described in earlier chapters,
we will create a struct, that will contain all the provided information to be
used later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasSerOffset</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFixedLengthLimit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasVarLengthLimits</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TLen</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">FixedLength</span><span class="o">&lt;</span><span class="n">TLen</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFixedLengthLimit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">FixedLengthLimit</span> <span class="o">=</span> <span class="n">TLen</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TOffset</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">NumValueSerOffset</span><span class="o">&lt;</span><span class="n">TOffset</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasSerOffset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">SerOffset</span> <span class="o">=</span> <span class="n">TOffset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TMinLen</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TMaxLen</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">VarLength</span><span class="o">&lt;</span><span class="n">TMinLen</span><span class="p">,</span> <span class="n">TMaxLen</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasVarLengthLimits</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">MinVarLength</span> <span class="o">=</span> <span class="n">TMinLen</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">MaxVarLength</span> <span class="o">=</span> <span class="n">TMaxLen</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_assemble_the_required_functionality">Assemble the Required Functionality</h4>
<div class="paragraph">
<p>Before parsing the options and assembling the right functionality there is a need
to start with basic integer value functionality:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFieldBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValueType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BasicIntValue</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TFieldBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="n">TValueType</span><span class="p">;</span>

    <span class="p">...</span> <span class="c1">// rest of the interface</span>
<span class="nl">private:</span>
    <span class="n">ValueType</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Such field receives its base class and the type of the value it stores. The
implementation of read/write/length functionalities are very basic and
straightforward.</p>
</div>
<div class="paragraph">
<p>Now, we need to prepare various adaptor classes that will wrap or replace the
existing interface functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TOffset</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SerOffsetAdaptor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span> <span class="c1">// public interface</span>
<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TLen</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FixedLengthAdaptor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span> <span class="c1">// public interface</span>
<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span> <span class="c1">// and so on</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that the adaptor classes above wrap one another (<code>TNext</code> template
parameter) and either replace or forward the read/write/length operations to the next
adaptor or final <code>BasicIntValue</code> class, instead of using inheritance as it was
with message interface and implementation chunks. The overall architecture
presented in this book doesn&#8217;t require the field classes to exhibit polymorphic
behaviour. That&#8217;s why using inheritance between adaptors is not necessary, although
not forbidden either. Using inheritance instead of containment has its pros and
cons, and at the end it&#8217;s a matter of personal taste of what to use.</p>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to use the parsed options and wrap the <code>BasicIntValue</code> with
required adaptors:</p>
</div>
<div class="paragraph">
<p>Wrap with <code>SerOffsetAdaptor</code> if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasSerOffset</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldSerOffset</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldSerOffset</span><span class="o">&lt;</span><span class="n">TField</span><span class="p">,</span> <span class="n">TOpts</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">SerOffsetAdaptor</span><span class="o">&lt;</span><span class="n">TOpts</span><span class="o">::</span><span class="n">SerOffset</span><span class="p">,</span> <span class="n">TField</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldSerOffset</span><span class="o">&lt;</span><span class="n">TField</span><span class="p">,</span> <span class="n">TOpts</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wrap with <code>FixedLengthAdaptor</code> if needed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasFixedLength</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldFixedLength</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldFixedLength</span><span class="o">&lt;</span><span class="n">TField</span><span class="p">,</span> <span class="n">TOpts</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">FixedLengthAdaptor</span><span class="o">&lt;</span><span class="n">TOpts</span><span class="o">::</span><span class="n">FixedLength</span><span class="p">,</span> <span class="n">TField</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TOpts</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AdaptBasicFieldFixedLength</span><span class="o">&lt;</span><span class="n">TField</span><span class="p">,</span> <span class="n">TOpts</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on for all other possible adaptors.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s bundle all the required adaptors together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBasic</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="n">sturct</span> <span class="n">FieldBuilder</span>
<span class="p">{</span>
    <span class="k">using</span>  <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">Field1</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AdaptBasicFieldSerOffset</span><span class="o">&lt;</span>
        <span class="n">TBasic</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasSerOffset</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">Field2</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AdaptBasicFieldFixedLength</span><span class="o">&lt;</span>
        <span class="n">Field1</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="p">,</span> <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasFixedLengthLimit</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">Field3</span> <span class="o">=</span> <span class="p">...</span>
    <span class="p">...</span>
    <span class="k">using</span> <span class="n">FieldN</span> <span class="o">=</span> <span class="p">...</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">FieldN</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The final stage is to actually define final <code>IntValueField</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValueType</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IntValueField</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Basic</span> <span class="o">=</span> <span class="n">BasicIntValue</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">TValueType</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Adapted</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">FieldBuilder</span><span class="o">&lt;</span><span class="n">Basic</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Adapted</span><span class="o">::</span><span class="n">ValueType</span><span class="p">;</span>

    <span class="c1">// Just forward all the API requests to the adapted field.</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">Adapted</span> <span class="n">m_adapted</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of the <strong>year</strong> field which is serialised using offset from
year <code>2000</code> may be defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyFieldBase</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// use big endian</span>
<span class="k">using</span> <span class="n">MyYear</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span>
    <span class="n">MyFieldBase</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">,</span> <span class="c1">// store as 2 bytes unsigned value</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">NumValueSerOffset</span><span class="o">&lt;-</span><span class="mi">2000</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FixedLength</span><b class="conum">(1)</b>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_options">Other Options</h4>
<div class="paragraph">
<p>In addition to options that regulate the read/write behaviour, there can be
options which influence how the field is created and/or handled afterwards.</p>
</div>
<div class="paragraph">
<p>For example, there may be a need to set a specific value when the field object
is created (using default constructor). Let&#8217;s introduce a new options for
this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">DefaultValueInitialiser</span><span class="p">{};</span>
<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The template parameter provided to this option is expected to be a class/struct
with the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">DefaultValueSetter</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// Set the custom value</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the relevant adaptor class may set the default value of the field using the
provided setter class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TSetter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DefaultValueInitAdaptor</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ValueType</span><span class="p">;</span>

    <span class="n">DefaultValueInitAdaptor</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">TSetter</span><span class="p">()(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that both <code>comms::option::DefaultValueInitialiser</code> option and
<code>DefaultValueInitAdaptor</code> adaptor class are completely generic, and
they can be used with any type of the field.</p>
</div>
<div class="paragraph">
<p>For numeric fields, such as <code>IntValueField</code> defined earlier, the generic library
may provide built-in setter class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TVal</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">DefaultNumValueInitialiser</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TField</span><span class="o">&amp;</span> <span class="n">field</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">FieldType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TField</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">FieldType</span><span class="o">::</span><span class="n">ValueType</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TVal</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then, create a convenience alias to <code>DefaultValueInitialiser</code> option which
receives a numeric value as its template parameter and insures that the
field&#8217;s value is initialised accordingly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">TVal</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">DefaultNumValue</span> <span class="o">=</span> <span class="n">DefaultValueInitialiser</span><span class="o">&lt;</span><span class="n">details</span><span class="o">::</span><span class="n">DefaultNumValueInitialiser</span><span class="o">&lt;</span><span class="n">TVal</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the result, the making the <strong>year</strong> field to be default constructed with
value <code>2016</code> may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyFieldBase</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// use big endian</span>
<span class="k">using</span> <span class="n">MyYear</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span>
    <span class="n">MyFieldBase</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">,</span> <span class="c1">// store as 2 bytes unsigned value</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">NumValueSerOffset</span><span class="o">&lt;-</span><span class="mi">2000</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FixedLength</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">DefaultNumValue</span><b class="conum">(2016)</b>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_fields">Other Fields</h4>
<div class="paragraph">
<p>The <a href="#fields-common_types">Common Field Types</a> chapter mentions multiple
other fields and several different ways to serialise them. I&#8217;m not going to
describe each and every one of them here. Instead, I&#8217;d recommend taking a look
at the documentation of the
<a href="https://github.com/commschamp/comms_champion#comms-library">COMMS library</a> which
was implemented using ideas from this book. It will describe all the fields
it implements and their options.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eliminating_dynamic_memory_allocation">Eliminating Dynamic Memory Allocation</h4>
<div class="paragraph">
<p>Fields like <strong>String</strong> or <strong>List</strong> may contain variable number of characters/elements.
The default internal value storage type for such fields will probably be
<code>std::string</code> or <code>std::vector</code> respectively. It will do the job, mostly. However,
they may not be suitable for bare-metal products that cannot use dynamic
memory allocation and/or exceptions. In this case there must be a way to
easily substitute these types with alternatives, such as custom <code>StaticString</code> or
<code>StaticVector</code> types.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s define a new option that will provide fixed storage size and will force
usage of these custom types instead of <code>std::string</code> and <code>std::vector</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FixedSizeStorage</span> <span class="p">{};</span>
<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parsed option structure needs to be extended with new information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFixedSizeStorage</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TSize</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">option</span><span class="o">::</span><span class="n">FixedSizeStorage</span><span class="o">&lt;</span><span class="n">TSize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">HasFixedSizeStorage</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">FixedSizeStorage</span> <span class="o">=</span> <span class="n">TSize</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s implement the logic of choosing <code>StaticString</code> as the value storage
type if the option above is used and choosing <code>std::string</code> if not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// TOptions is a final variant of FieldParsedOptions&lt;...&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TOptions</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasFixedStorage</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StringStorageType</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StringStorageType</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">comms</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">StaticString</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="o">::</span><span class="n">FixedSizeStorage</span><span class="o">&gt;</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StringStorageType</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">StringStorageTypeT</span> <span class="o">=</span>
    <span class="k">typename</span> <span class="n">StringStorageType</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">,</span> <span class="n">TOptions</span><span class="o">::</span><span class="n">HasFixedSizeStorage</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comms::util::StaticString</code> is the implementation of a string management class,
which exposes the same public interface as <code>std::string</code>. It receives the fixed size
of the storage area as a template parameter, uses <code>std::array</code> or similar as its private
data member the store the string characters.</p>
</div>
<div class="paragraph">
<p>The implementation of the <strong>String</strong> field may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TBase</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StringField</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Parse the option into the struct</span>
    <span class="k">using</span> <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="n">FieldParsedOptions</span><span class="o">&lt;</span><span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// Identify storage type: StaticString or std::string</span>
    <span class="k">using</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="n">StringStorageTypeT</span><span class="o">&lt;</span><span class="n">ParsedOptions</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// Use the basic field and wrap it with adapters just like IntValueField earlier</span>
    <span class="k">using</span> <span class="n">Basic</span> <span class="o">=</span> <span class="n">BasicStringValue</span><span class="o">&lt;</span><span class="n">TBase</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Adapted</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">FieldBuilder</span><span class="o">&lt;</span><span class="n">Basic</span><span class="p">,</span> <span class="n">TOptions</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>

    <span class="c1">// Just forward all the API requests to the adapted field.</span>
    <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">ValueType</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_adapted</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">Adapted</span> <span class="n">m_adapted</span><span class="p">;</span>
<span class="p">};</span>
<span class="err">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the result the definition of the message with a string field that doesn&#8217;t
use dynamic memory allocation may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFieldBase</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">ActualMessage3Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">StringField</span><span class="o">&lt;</span><span class="n">TFieldBase</span><span class="p">,</span> <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FixedStorageSize</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;:</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage3</span> <span class="o">:</span> <span class="k">public</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">ActualMessage3Fields</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="o">::</span><span class="n">Field</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span>
        <span class="p">...</span>
    <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And what about the case, when there is a need to create a message with a
string field, but substitute the underlying default <code>std::string</code> type with
<code>StaticString</code> <strong>only</strong> when compiling the bare-metal application? In this
case the <code>ActualMessage3</code> class may be defined to have additional template
parameter which will determine the necessity to substitute the storage type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">THasFixedSize</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StringExtraOptions</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">EmtpyOption</span><span class="p">;</span> <span class="c1">// doesn't do anything</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">StringExtraOptions</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FixedStorageSize</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span> <span class="c1">// forces static storage</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TFieldBase</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasFixedSize</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">ActualMessage3Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">StringField</span><span class="o">&lt;</span><span class="n">TFieldBase</span><span class="p">,</span> <span class="k">typename</span> <span class="n">StringExtraOptions</span><span class="o">&lt;</span><span class="n">THasFixedSize</span><span class="o">&gt;::</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;:</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">THasFixedSize</span> <span class="o">=</span> <span class="nb">false</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage3</span> <span class="o">:</span> <span class="k">public</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">ActualMessage3Fields</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgInterface</span><span class="o">::</span><span class="n">Field</span><span class="p">,</span> <span class="n">THasFixedSize</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span>
        <span class="p">...</span>
    <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Thanks to the fact that <code>StaticString</code> and <code>std::string</code> classes expose the
same public interface, the message handling function doesn&#8217;t need to worry about
actual storage type. It just uses public interface of <code>std::string</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MsgHandler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">ActualMessage3</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">fields</span><span class="p">();</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">stringField</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fields</span><span class="p">);</span>

        <span class="c1">// The type of the stringVal is either std::string or StaticString</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">stringVal</span> <span class="o">=</span> <span class="n">stringField</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stringVal</span> <span class="o">==</span> <span class="s">"string1"</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span> <span class="c1">// do something</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stringVal</span> <span class="o">==</span> <span class="s">"string2"</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span> <span class="c1">// do something else</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Choosing internal value storage type for <strong>List</strong> fields to be
<code>std::vector</code> or <code>StaticVector</code> is very similar.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transport-transport">Transport</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to definition of the messages and their contents, every
communication protocol must ensure that the message is successfully delivered
over the I/O link to the other side. The serialised message payload must be
wrapped in some kind of transport information, which usually depends on the
type and reliability of the I/O link being used. For example, protocols that
are designed to be used over TCP/IP connection, such as <a href="http://mqtt.org">MQTT</a>,
may omit the whole packet synchronisation and checksum logic, because TCP/IP
connection ensures that the data is delivered correctly. Such protocols are
usually defined to use only message ID and remaining size information to wrap
the message payload:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>ID | SIZE | PAYLOAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other protocols may be designed to be used over less reliable RS-232 link,
which may require a bit better protection against data loss or corruption:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>SYNC | SIZE | ID | PAYLOAD | CHECKSUM</code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of most common types of the wrapping "chunks" is quite small.
However, different protocols may have different rules of how these values are
serialised. Very similar to <a href="#fields-fields">Fields</a>.</p>
</div>
<div class="paragraph">
<p>The main logic of processing the incoming raw data remains the same for
all the protocols, though. It is to read and process the transport information "chunks" one
by one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SYNC - check the next one or more bytes for an expected predefined value.
If the value is as expected proceed to the next "chunk". If not, drop one
byte from the front of the incoming data queue and try again.</p>
</li>
<li>
<p>SIZE - compare the remaining expected data length against actually available. If
there is enough data, proceed to the next "chunk". If not report, to the
caller, that more data is required.</p>
</li>
<li>
<p>ID - read the message ID value and create appropriate message object, then
proceed to the next "chunk".</p>
</li>
<li>
<p>PAYLOAD - let the created message object to read its payload data.</p>
</li>
<li>
<p>CHECKSUM - read the expected checksum value and calculate the actual one. If
the checksums don&#8217;t match, discard the created message and report error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each and every "chunk" operates independently, regardless of what information
was processed before and/or after it. When some operation seems to repeat itself
several times, it should be generalised and become part of our
<a href="#library-library">Generic Library</a>.</p>
</div>
<div class="paragraph">
<p>So, how is it going to be implemented? My advice is to use independent "chunk"
classes, that expose predefined interface, wrap one another, and forward
the requested operation to the next "chunk" when appropriate. As was stated
earlier, the transport information values are very similar to
<a href="#fields-fields">Fields</a>, which immediately takes us to the direction of
reusing <a href="#fields-fields">Field</a> classes to handle these values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNextChunk</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* some other template parameters */</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SomeChunk</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Iterator used for reading</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNextChunk</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Iterator used for writing</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNextChunk</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Type of the common message interface class</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNextChunk</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Smart pointer used to hold newly created message object</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNextChunk</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>

    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">MsgPtr</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">...</span> <span class="n">process</span> <span class="n">field</span> <span class="n">value</span><span class="p">.</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// set required value</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNextChunk</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that <code>ReadIterator</code> and <code>WriteIterator</code> are taken from the next
chunk. One of the chunks, which is responsible for processing the <code>PAYLOAD</code> will
receive the class of the message interface as a template parameter, will
retrieve the information of the iterators' types, and redefine them as its
internal types. Also, this class will define the type of the message interface as
its internal <code>Message</code> type.
All other wrapping chunk classes will reuse the same information.</p>
</div>
<div class="paragraph">
<p>Also note, that one of the chunks will have to define pointer to the created
message object (<code>MsgPtr</code>). Usually it is the chunk that is responsible to process <code>ID</code>
value.</p>
</div>
<div class="paragraph">
<p>The sequential processing the transport information "chunks", and stripping
them one by one before proceeding to the next one, may remind of
<a href="https://en.wikipedia.org/wiki/OSI_model">OSI Conceptual Model</a>, where
a layer serves the layer above it and is served by the layer below it.</p>
</div>
<div class="paragraph">
<p>From now on, I will use a term <strong>layer</strong> instead of the <strong>chunk</strong>.
The combined bundle of such layers will be called
<strong>protocol stack</strong> (of layers).</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a closer look at all the layer types mentioned above.</p>
</div>
<div class="sect2">
<h3 id="transport-payload">PAYLOAD Layer</h3>
<div class="paragraph">
<p>Processing of the <code>PAYLOAD</code> is always the last stage in the protocol stack.
All previous layers have successfully processed their transport data, the
message object was created and is ready to read its fields encoded in the PAYLOAD.</p>
</div>
<div class="paragraph">
<p>Such layer must receive type of the message interface class as a template
parameter and redefine read/write iterator types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgDataLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Define type of the message interface</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="n">TMessage</span><span class="p">;</span>

    <span class="c1">// Type of the pointer to message is not defined yet, will be defined in</span>
    <span class="c1">// the layer that processes message ID</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>

    <span class="c1">// ReadIterator is the same as Message::ReadIterator if such exists, void</span>
    <span class="c1">// otherwise.</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
            <span class="n">Message</span><span class="o">::</span><span class="n">InterfaceOptions</span><span class="o">::</span><span class="n">HasReadIterator</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">TMessage</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">,</span>
            <span class="kt">void</span>
        <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

    <span class="c1">// WriteIterator is the same as Message::WriteIterator if such exists, void</span>
    <span class="c1">// otherwise.</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
            <span class="n">Message</span><span class="o">::</span><span class="n">InterfaceOptions</span><span class="o">::</span><span class="n">HasWriteIterator</span><span class="p">,</span>
            <span class="k">typename</span> <span class="n">TMessage</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">,</span>
            <span class="kt">void</span>
        <span class="o">&gt;::</span><span class="n">type</span> <span class="n">WriteIterator</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The read/write operations just forward the request the message object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgDataLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgPtr</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span>
        <span class="n">TMsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span>
        <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">msgPtr</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span>
        <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">msg</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that <code>read()</code> member function expects to receive a reference to
the smart pointer, which holds allocated message object, as the first parameter.
The type of the pointer is not known yet.
As the result, type of such pointer is provided via
template parameter.</p>
</div>
</div>
<div class="sect2">
<h3 id="transport-id">ID Layer</h3>
<div class="paragraph">
<p>The job of this layer is handle the message ID information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When new message
is received, appropriate message object needs to be created, prior to
invoking read operation of the next (wrapped) layer.</p>
</li>
<li>
<p>When any message
is about to get sent, just get the ID information from the message object and
serialise it prior to invoking the write operation of the next layer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The code of the layer is pretty straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TField is type of the field used to read/write message ID</span>
<span class="c1">// TNext is the next layer this one wraps</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* other parameters */</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the field object used to read/write message ID value.</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>

    <span class="c1">// Take type of the ReadIterator from the next layer</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the WriteIterator from the next layer</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Type of the message ID</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Message</span><span class="o">::</span><span class="n">MsgIdType</span><span class="p">;</span>

    <span class="c1">// Redefine pointer to message type (described later)</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">MsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">msgPtr</span> <span class="o">=</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">());</span> <span class="c1">// create message object based on ID</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msgPtr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Unknown ID</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">InvalidMsgId</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">msgPtr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// Discard allocated message;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">id</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">MsgIdType</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// TODO: create message object (described later)</span>
    <span class="p">}</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To properly finalise the implementation above we need to resolve two main challenges:
- Implement <code>createMsg()</code> function which receives ID of the message and
creates the message object.
- Define the <code>MsgPtr</code> smart pointer type, which is responsible to hold the
allocated message object. In most cases defining it to be
<code>std::unique_ptr&lt;Message&gt;</code> will do the job. However, the main problem here is usage of dynamic memory
allocation. Bare metal platform may not have such luxury. There must be a
way to support
<a href="https://en.wikipedia.org/wiki/Placement_syntax">"in place" allocation</a> as well.</p>
</div>
<div class="sect3">
<h4 id="_creating_message_object">Creating Message Object</h4>
<div class="paragraph">
<p>Let&#8217;s start with creation of proper message object, given the <strong>numeric</strong> message ID.
It must be as efficient as possible.</p>
</div>
<div class="paragraph">
<p>In many cases the IDs of the messages are sequential ones and defined using
some enumeration type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">MsgId</span>
<span class="p">{</span>
    <span class="n">MsgId_Message1</span><span class="p">,</span>
    <span class="n">MsgId_Message2</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="n">MsgId_NumOfMessages</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we have <code>FactoryMethod</code> class with polymorphic <code>createMsg()</code>
function, that returns allocated message object wrapped in a <code>MsgPtr</code> smart pointer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">FactoryMethod</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">createMsgImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">MsgPtr</span> <span class="n">createMsgImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the most efficient way is to have an array of pointers to
polymorphic class <code>FactoryMethod</code>. The index of the array cell corresponds to
a message ID.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/msg_factory.png" alt="Image: Message Factory">
</div>
</div>
<div class="paragraph">
<p>The code of <code>MsgIdLayer::createMsg()</code> function is quite simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">MsgIdType</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">registry</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// reference to the array of pointers to FactoryMethod-s</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">registry</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">id</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">registry</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)){</span>
            <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">registry</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">createMsg</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The runtime <a href="https://en.wikipedia.org/wiki/Time_complexity">complexity</a>
of such code is <code>O(1)</code>.</p>
</div>
<div class="paragraph">
<p>However, there are many protocols that their ID map is quite sparse and it is
impractical to use an array for direct mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">MsgId</span>
<span class="p">{</span>
    <span class="n">MsgId_Message1</span> <span class="o">=</span> <span class="mh">0x0101</span><span class="p">,</span>
    <span class="n">MsgId_Message2</span> <span class="o">=</span> <span class="mh">0x0205</span><span class="p">,</span>
    <span class="n">MsgId_Message3</span> <span class="o">=</span> <span class="mh">0x0308</span><span class="p">,</span>
    <span class="p">...</span>
    <span class="n">MsgId_NumOfMessages</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the array of <code>FactoryMethod</code>-s described earlier must be packed and
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a> algorithm
used to find required method. To support such search, the <code>FactoryMethod</code> must
be able to report ID of the messages it creates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">FactoryMethod</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MsgIdType</span> <span class="n">id</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">idImpl</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">createMsgImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">MsgIdType</span> <span class="n">idImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">MsgPtr</span> <span class="n">createMsgImpl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the code of <code>MsgIdLayer::createMsg()</code> needs to apply binary search to find
the required method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">MsgIdType</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">registry</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// reference to the array of pointers to FactoryMethod-s</span>
        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span>
                <span class="n">registry</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">registry</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">id</span><span class="p">,</span>
                <span class="p">[](</span><span class="n">FactoryMethod</span><span class="o">*</span> <span class="n">method</span><span class="p">,</span> <span class="n">MsgIdType</span> <span class="n">idVal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">method</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">idVal</span><span class="p">;</span>
                <span class="p">});</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">iter</span> <span class="o">==</span> <span class="n">registry</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">||</span>
            <span class="p">((</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()</span> <span class="o">!=</span> <span class="n">id</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">createMsg</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that <a href="http://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound</a>
algorithm requires <code>FactoryMethod</code>-s in the
"registry" to be sorted by the message ID. The runtime
<a href="https://en.wikipedia.org/wiki/Time_complexity">complexity</a>
of such code is <code>O(log(n))</code>, where <code>n</code> is size of the registry.</p>
</div>
<div class="paragraph">
<p>Some communication protocols define multiple variants of the same message, which
are differentiated by some other means, such as serialisation length of the message.
It may be convenient to implement such variants as separate message classes, which
will require separate <code>FactoryMethod</code>-s to instantiate them. In this case,
the <code>MsgIdLayer::createMsg()</code> function may use
<a href="http://en.cppreference.com/w/cpp/algorithm/equal_range">std::equal_range</a>
algorithm instead of
<a href="http://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound</a>, and
use additional parameter to specify which of the methods to pick from the equal
range found:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">MsgIdType</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">registry</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// reference to the array of pointers to FactoryMethod-s</span>
        <span class="k">auto</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_range</span><span class="p">(...);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">iters</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">iters</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">iters</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">iters</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">idx</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">idx</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">createMsg</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that <code>MsgIdLayer::read()</code> function also needs to be modified to
support multiple attempts to create message object with the same id.
It must increment the <code>idx</code> parameter, passed to <code>createMsg()</code> member function,
on every failing attempt to read the message contents, and try again
until the found equal range is exhausted. I leave the implementation of
this extra logic as an exercise to the reader.</p>
</div>
<div class="paragraph">
<p>To complete the message allocation subject we need to come up with an automatic
way to create the registry of <code>FactoryMethod</code>-s used earlier. Please remember,
that <code>FactoryMethod</code> was just a polymorphic interface. We need to implement
actual method that implements the virtual functionality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TActualMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualFactoryMethod</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FactoryMethod</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="n">MsgIdType</span> <span class="n">idImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">TActualMessage</span><span class="o">::</span><span class="n">ImplOptions</span><span class="o">::</span><span class="n">MsgId</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">MsgPtr</span> <span class="n">createMsgImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">TActualMessage</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that the code above assumes that <code>comms::option::StaticNumIdImpl</code>
option (described in <a href="#library-impl">Generalising Message Implementation</a> chapter)
was used to specify numeric message ID
when defining the <code>ActualMessage*</code> class.</p>
</div>
<div class="paragraph">
<p>Also note, that the example above uses dynamic memory allocation to allocate
actual message object. This is just for idea demonstration purposes. The
<a href="#transport-id-alloc">Allocating Message Object</a> section below will
describe how to support "in-place" allocation.</p>
</div>
<div class="paragraph">
<p>The types of the messages, that can be received over I/O link, are usually known
at compile time. If we bundle them together in <code>std::tuple</code>, it is easy to
apply already familiar meta-programming technique of iterating over the provided
types and instantiate proper <code>ActualFactoryMethod&lt;&gt;</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">AllMessages</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">ActualMessage1</span><span class="p">,</span>
    <span class="n">ActualMessage2</span><span class="p">,</span>
    <span class="n">ActualMessage3</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The size of the <strong>registry</strong> can easily be identified using
<a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_size">std::tuple_size</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">static</span> <span class="k">const</span> <span class="n">RegistrySize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">AllMessages</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Registry</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">FactoryMethod</span><span class="o">*</span><span class="p">,</span> <span class="n">RegistrySize</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">Registry</span> <span class="n">m_registry</span><span class="p">;</span> <span class="c1">// registry object</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to iterate (at compile time) over all the types defined in
the <code>AllMessages</code> tuple and create separate <code>ActualFactoryMethod&lt;&gt;</code> for
each and every one of them. Remember <a href="#appendix-a">tupleForEach</a>? We need
something similar here, but missing the tuple object itself. We are just iterating
over types, not the elements of the tuple object. We&#8217;ll call it
<code>tupleForEachType()</code>. See <a href="#appendix-d">Appendix D - tupleForEachType</a> for implementation details.</p>
</div>
<div class="paragraph">
<p>We also require a functor class that will be invoked for every message type and
will be responsible to fill the provided registry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MsgFactoryCreator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MsgFactoryCreator</span><span class="p">(</span><span class="n">Registry</span><span class="o">&amp;</span> <span class="n">registry</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">registry_</span><span class="p">(</span><span class="n">registry</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">ActualFactoryMethod</span><span class="o">&lt;</span><span class="n">TMessage</span><span class="o">&gt;</span> <span class="n">Factory</span><span class="p">;</span>
        <span class="n">registry_</span><span class="p">[</span><span class="n">idx_</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Factory</span><span class="p">;</span>
        <span class="o">++</span><span class="n">idx_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Registry</span><span class="o">&amp;</span> <span class="n">registry_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">idx_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The initialisation function may be as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">initRegistry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">tupleForEachType</span><span class="o">&lt;</span><span class="n">AllMessages</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MsgFactoryCreator</span><span class="p">(</span><span class="n">m_registry</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that <code>ActualFactoryMethod&lt;&gt;</code> factories do not have any internal state and
are defined as static objects. It is safe just to store pointers to them in
the <strong>registry</strong> array.</p>
</div>
<div class="paragraph">
<p>To summarise this section, let&#8217;s redefine <code>comms::MsgIdLayer</code> and add
the message creation functionality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TField is type of the field used to read/write message ID</span>
<span class="c1">// TAllMessages is all messages bundled in std::tuple.</span>
<span class="c1">// TNext is the next layer this one wraps</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TAllMessages</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the field object used to read/write message ID value.</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>

    <span class="c1">// Take type of the ReadIterator from the next layer</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the WriteIterator from the next layer</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Type of the message ID</span>
    <span class="k">using</span> <span class="n">MsgIdType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Message</span><span class="o">::</span><span class="n">MsgIdType</span><span class="p">;</span>

    <span class="c1">// Redefine pointer to message type:</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Constructor</span>
    <span class="n">MsgIdLayer</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">tupleForEachType</span><span class="o">&lt;</span><span class="n">AllMessages</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MsgFactoryCreator</span><span class="p">(</span><span class="n">m_registry</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// Read operation</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">MsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{...}</span>

    <span class="c1">// Write operation</span>
    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span> <span class="p">{...}</span>

<span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">FactoryMethod</span> <span class="p">{...};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ActualFactoryMethod</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FactoryMethod</span> <span class="p">{...};</span>

    <span class="k">class</span> <span class="nc">MsgFactoryCreator</span> <span class="p">{...};</span>

    <span class="c1">// Registry of Factories</span>
    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">RegistrySize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">TAllMessages</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Registry</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">FactoryMethod</span><span class="o">*</span><span class="p">,</span> <span class="n">RegistrySize</span><span class="o">&gt;</span><span class="p">;</span>


    <span class="c1">// Create message</span>
    <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">MsgIdType</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_range</span><span class="p">(</span><span class="n">m_registry</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_registry</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">...);</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="n">Registry</span> <span class="n">m_registry</span><span class="p">;</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transport-id-alloc">Allocating Message Object</h4>
<div class="paragraph">
<p>At this stage, the only missing piece of information is definition of the
smart pointer type responsible to hold the allocated message object (<code>MsgPtr</code>)
and allowing "in place" allocation instead of using dymaic memory.</p>
</div>
<div class="paragraph">
<p>When dynamic memory allocation is allowed, everything is simple, just use
<code>std::unique_ptr</code> with standard deleter. However, it is a bit more difficult
when such allocations are not allowed.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with the calculation of the buffer size which is big enough to
hold any message in the provided <code>AllMessages</code> bundle. It is similar to the
size of the <code>union</code> below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">union</span> <span class="n">AllMessagesU</span>
<span class="p">{</span>
    <span class="n">ActualMessage1</span> <span class="n">msg1</span><span class="p">;</span>
    <span class="n">ActualMessage2</span> <span class="n">msg2</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, all the required message types are provided as <code>std::tuple</code>, not
as <code>union</code>. What we need is something like
<a href="http://en.cppreference.com/w/cpp/types/aligned_union">std::aligned_union</a>, but
for the types already bundled in <code>std::tuple</code>. It turns out it is very easy to
implement using template specialisation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">TupleAsAlignedUnion</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TTypes</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">TupleAsAlignedUnion</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">TTypes</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_union</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">TTypes</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>NOTE</strong>, that some compilers (gcc v5.0 and below) may not implement
<code>std::aligned_union</code> type, but they do implement
<a href="http://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a>.
The <a href="#appendix-e">Appendix E - AlignedUnion</a> shows how to implement aligned union
functionality using <code>std::aligned_storage</code>.</p>
</div>
<div class="paragraph">
<p>The "in place" allocation area, that can fit in any message type listed in
<code>AllMessages</code> tuple, can be defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">InPlaceStorage</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TupleAsAlignedUnion</span><span class="o">&lt;</span><span class="n">AllMessages</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The "in place" allocation is simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">InPlaceStorage</span> <span class="n">inPlaceStorage</span><span class="p">;</span>
<span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">inPlaceStorage</span><span class="p">)</span> <span class="n">TMessage</span><span class="p">();</span> <span class="c1">// TMessage is type of the message being created.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The "in place" allocation requires "in place" deletion, i.e. destruction of
the allocated element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">InPlaceDeleter</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">obj</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The smart pointer to <code>Message</code> interface class may be defined as
<code>std::unique_ptr&lt;Message, InPlaceDeleter&lt;Message&gt; &gt;</code>.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s define two independent allocation policies with the similar interface.
One for dynamic memory allocation, and the other for "in place" allocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessageInterface</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">DynMemAllocationPolicy</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TMessageInterface</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
    <span class="n">MsgPtr</span> <span class="n">allocMsg</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">TMessage</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessageInterface</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TAllMessages</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">InPlaceAllocationPolicy</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">InPlaceDeleter</span> <span class="p">{...};</span>

    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TMessageInterface</span><span class="p">,</span> <span class="n">InPlaceDeleter</span><span class="o">&lt;</span><span class="n">TMessageInterface</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
    <span class="n">MsgPtr</span> <span class="n">allocMsg</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">m_storage</span><span class="p">)</span> <span class="n">TMessage</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">MsgPtr</span><span class="p">(</span>
            <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">TMessageInterface</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_storage</span><span class="p">),</span>
            <span class="n">InPlaceDeleter</span><span class="o">&lt;</span><span class="n">TMessageInterface</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">using</span> <span class="n">InPlaceStorage</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TupleAsAlignedUnion</span><span class="o">&lt;</span><span class="n">TAllMessages</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>
    <span class="n">InPlaceStorage</span> <span class="n">m_storage</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please pay attention, that the implementation of <code>InPlaceAllocationPolicy</code> is
the simplest possible one. In production quality code, it is recommended to insert
protection against double allocation
in the used storage area, by introducing boolean flag indicating, that the
storage area is or isn&#8217;t free. The pointer/reference to such flag must also be
passed to the deleter object, which is responsible to update it when deletion takes
place.</p>
</div>
<div class="paragraph">
<p>The choice of the allocation policy used in <code>comms::MsgIdLayer</code> may be implemented
using the already familiar technique of using options.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TField</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TAllMessages</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TNext</span><span class="p">,</span>
    <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If no option is specified, the <code>DynMemAllocationPolicy</code> must be chosen. To
force "in place" message allocation a separate option may be defined and
passed as template parameter to <code>comms::MsgIdLayer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">option</span>
<span class="p">{</span>
<span class="k">struct</span> <span class="n">InPlaceAllocation</span> <span class="p">{};</span>
<span class="p">}</span> <span class="c1">// namespace option</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the familiar technique of options parsing, we can create a structure,
where a boolean value <code>HasInPlaceAllocation</code> defaults to <code>false</code> and can be
set to <code>true</code>, if the option mentioned above is used. As the result, the policy choice
may be implemented as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TField</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TAllMessages</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TNext</span><span class="p">,</span>
    <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// TOptions parsed into struct</span>
    <span class="k">using</span> <span class="n">ParsedOptions</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Choice of the allocation policy</span>
    <span class="k">using</span> <span class="n">AllocPolicy</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
        <span class="n">ParsedOptions</span><span class="o">::</span><span class="n">HasInPlaceAllocation</span><span class="p">,</span>
        <span class="n">InPlaceAllocationPolicy</span><span class="o">&lt;</span><span class="n">Message</span><span class="p">,</span> <span class="n">TAllMessages</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">DynMemAllocationPolicy</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
    <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

    <span class="c1">// Redefine pointer to message type</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AllocPolicy</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="n">AllocPolicy</span> <span class="n">m_policy</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>What remains to be done is to provide the <code>ActualFactoryMethod&lt;&gt;</code> class with
an ability to use allocation policy for allocating the message. Please
remember, that <code>ActualFactoryMethod&lt;&gt;</code> objects are stateless static ones. It
means that the allocation policy object needs to passed as the parameter to
its allocation function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TField</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TAllMessages</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TNext</span><span class="p">,</span>
    <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Choice of the allocation policy</span>
    <span class="k">using</span> <span class="n">AllocPolicy</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="c1">// Redefine pointer to message type</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AllocPolicy</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>
    <span class="p">...</span>
<span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">FactoryMethod</span>
    <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">MsgPtr</span> <span class="n">createMsg</span><span class="p">(</span><span class="n">AllocPolicy</span><span class="o">&amp;</span> <span class="n">policy</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">createMsgImpl</span><span class="p">(</span><span class="n">policy</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="nl">protected:</span>
        <span class="k">virtual</span> <span class="n">MsgPtr</span> <span class="n">createMsgImpl</span><span class="p">(</span><span class="n">AllocPolicy</span><span class="o">&amp;</span> <span class="n">policy</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TActualMessage</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ActualFactoryMethod</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FactoryMethod</span>
    <span class="p">{</span>
    <span class="nl">protected:</span>
        <span class="k">virtual</span> <span class="n">MsgPtr</span> <span class="n">createMsgImpl</span><span class="p">(</span><span class="n">AllocPolicy</span><span class="o">&amp;</span> <span class="n">policy</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">policy</span><span class="p">.</span><span class="n">allocMsg</span><span class="o">&lt;</span><span class="n">TActualMessage</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">AllocPolicy</span> <span class="n">m_policy</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summary_2">Summary</h4>
<div class="paragraph">
<p>The final implementation of the ID Layer (<code>comms::MsgIdLayer</code>) is a generic
piece of code. It receives a list of message classes, it must recognise,
as a template parameter. The whole logic of creating the right message object
given the numeric ID of the message is automatically generated by the compiler
using only static memory. When new message is added to the protocol, what needs
to be updated is the bundle of available message classes (<code>AllMessages</code>). Nothing
else is required. Recompilation of the sources will generate a code that
supports new message as well. The implementation of <code>comms::MsgIdLayer</code>
above has <code>O(log(n))</code> runtime complexity of finding the right factory method
and creating appropriate message object. It also supports multiple variants
of the same message which are implemented as different message classes, but
report the same message ID. By default <code>comms::MsgIdLayer</code> uses dynamic
memory to allocate new message object. It can easily be changed by providing
<code>comms::option::InPlaceAllocation</code> option to it, which will force usage of
"in place" allocation. The "in place" allocation may create one message at
a time. In order to be able to create a new message object, the previous
one must be destructed and de-allocated before.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transport-size">SIZE Layer</h3>
<div class="paragraph">
<p>This layer is responsible to handle the remaining length information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>During read operation it reads the information about number of
bytes required to complete the message deserialisation and compares
it to the number of bytes available for reading. If input buffer has
enough data, the read operation of the next (wrapped) layer is invoked.</p>
</li>
<li>
<p>During write operation, the layer must calculate and write the
number of bytes required to serialise the message prior to invoking the
write operation of the next (wrapped) layer.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TField is type of the field used to read/write SIZE information</span>
<span class="c1">// TNext is the next layer this one wraps</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgSizeLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the field object used to read/write SIZE information.</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>

    <span class="c1">// Take type of the ReadIterator from the next layer</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the WriteIterator from the next layer</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface pointer from the next layer</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgPtr</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TMsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">actualRemainingSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">auto</span> <span class="n">requiredRemainingSize</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">actualRemainingSize</span> <span class="o">&lt;</span> <span class="n">requiredRemainingSize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">NotEnoughData</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">msgPtr</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">requiredRemainingSize</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">NotEnoughData</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">ProtocolError</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that reference to the smart pointer holding the message object is passed to
the <code>read()</code> function using <strong>undefined</strong> type (template parameter) instead of
using the <code>MsgPtr</code> internal type.
Some communication protocols may serialise <code>SIZE</code> information before the <code>ID</code>,
others may do the opposite.
The <code>SIZE</code> layer is not aware of what other layers it wraps.
If <code>ID</code> information is
serialised before the <code>SIZE</code>, the <code>MsgPtr</code> type definition is probably taken
from <a href="#transport-payload">PAYLOAD Layer</a>, which is defined to be <code>void</code>.</p>
</div>
<div class="paragraph">
<p>Also note, that <code>write()</code> function requires knowledge of how many bytes it
will take to the next layer to serialise the message. It requires every layer
to define <code>length(&#8230;&#8203;)</code> member function in addition to <code>read()</code> and <code>write()</code>.</p>
</div>
<div class="paragraph">
<p>The <code>length()</code> member function of the <a href="#transport-payload">PAYLOAD Layer</a> may be defined
as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgDataLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">(</span><span class="k">const</span> <span class="n">TMessage</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">msg</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>length()</code> member function of the <a href="#transport-id">ID Layer</a> may be defined
as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TField</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TAllMessages</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">TNext</span><span class="p">,</span>
    <span class="k">typename</span><span class="p">...</span> <span class="n">TOptions</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">id</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_next</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>length()</code> member function of the <a href="#transport-size">SIZE Layer</a> itself may be defined
as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgSizeLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transport-sync">SYNC Layer</h3>
<div class="paragraph">
<p>This layer is responsible to find and validate the synchronisation prefix.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TField is type of the field used to read/write SYNC prefix</span>
<span class="c1">// TNext is the next layer this one wraps</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SyncPrefixLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the field object used to read/write SYNC prefix.</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>

    <span class="c1">// Take type of the ReadIterator from the next layer</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the WriteIterator from the next layer</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface pointer from the next layer</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgPtr</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TMsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Field</span><span class="p">().</span><span class="n">value</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// doesn't match expected</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">ProtocolError</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">msgPtr</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">(</span><span class="k">const</span> <span class="n">TMessage</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Field</span><span class="p">().</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_next</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, that the value of the <code>SYNC</code> prefix is expected to be equal to the value
of the default constructed <code>TField</code> field type. The default construction value
may be set using <code>comms::option::DefaultNumValue</code> option described in
<a href="#library-fields">Generalising Fields Implementation</a> chapter.</p>
</div>
<div class="paragraph">
<p>For example, 2 bytes synchronisation prefix <code>0xab 0xcd</code> with big endian
serialisation may be defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">CommonFieldBase</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// big endian serialisation base</span>
<span class="k">using</span> <span class="n">SyncPrefixField</span> <span class="o">=</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span>
        <span class="n">CommonFieldBase</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">DefaultNumValue</span><span class="o">&lt;</span><span class="mh">0xabcd</span><span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transport-checksum">CHECKSUM Layer</h3>
<div class="paragraph">
<p>This layer is responsible to calculate and validate the checksum information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>During read operation it remembers the initial value of the read iterator,
then invokes the read operation of the next (wrapped) layer. After the
next layer reports successful completion of its read operation, the expected checksum
value is read. Then, the real checksum on the read data bytes is calculated and
compered to the expected one. If the values match, the read operation is
reported as successfully complete. If not, the created message object is
deleted and error reported.</p>
</li>
<li>
<p>During write operation it lets the next (wrapped) layer to finish its
writing, calculates the checksum value on the written
data bytes, and writes the result into output buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before jumping into writing the code, there is a need to be aware of couple of
issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The generic code of the <strong>CHECKSUM Layer</strong> mustn&#8217;t depend on any particular
checksum calculation algorithm. I&#8217;d recommend providing the calculator class as a template
parameter, <code>operator()</code> of which is responsible to implement the checksum
calculation logic.</p>
</li>
<li>
<p>The checksum calculation after write operation requires the iterator to
go back and calculate the checksum on the written data bytes. It can easily
be done when used iterator is
<a href="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator">random access</a>
one. Sometimes it may not
be the case (for example the output data is written into
<a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a> using
<a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</a>).
There is a need to have a generic way to handle such cases.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_implementing_read_2">Implementing Read</h4>
<div class="paragraph">
<p>Let&#8217;s start with implementing the read first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="c1">// TField is type of the field used to read/write checksum value</span>
<span class="c1">// TCalc is generic class that is responsible to implement checksum calculation logic</span>
<span class="c1">// TNext is the next layer this one wraps</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TField</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TCalc</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ChecksumLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Type of the field object used to read/write SYNC prefix.</span>
    <span class="k">using</span> <span class="n">Field</span> <span class="o">=</span> <span class="n">TField</span><span class="p">;</span>

    <span class="c1">// Take type of the ReadIterator from the next layer</span>
    <span class="k">using</span> <span class="n">ReadIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the WriteIterator from the next layer</span>
    <span class="k">using</span> <span class="n">WriteIterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">WriteIterator</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface from the next layer</span>
    <span class="k">using</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">Message</span><span class="p">;</span>

    <span class="c1">// Take type of the message interface pointer from the next layer</span>
    <span class="k">using</span> <span class="n">MsgPtr</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">TNext</span><span class="o">::</span><span class="n">MsgPtr</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMsgPtr</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">read</span><span class="p">(</span><span class="n">TMsgPtr</span><span class="o">&amp;</span> <span class="n">msgPtr</span><span class="p">,</span> <span class="n">ReadIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">NotEnoughData</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">fromIter</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">// The read is expected to use random-access iterator</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">consumedLen</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">iter</span><span class="p">));</span>
        <span class="k">auto</span> <span class="n">remLen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">consumedLen</span><span class="p">;</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">remLen</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">msgPtr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">TCalc</span><span class="p">()(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">consumedLen</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">expectedValue</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">expectedValue</span> <span class="o">!=</span> <span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">msgPtr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// Delete allocated message</span>
            <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">ProtocolError</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is clear that <code>TCalc</code> class is expected to have <code>operator()</code> member
function, which receives the iterator for reading and number of bytes
in the buffer.</p>
</div>
<div class="paragraph">
<p>As an example let&#8217;s implement generic total sum of bytes calculator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TResult</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BasicSumCalc</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">TResult</span> <span class="k">operator</span><span class="p">()(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">ByteType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned</span><span class="o">&lt;</span>
            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>
        <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">TResult</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">checksum</span> <span class="o">+=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TResult</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ByteType</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
            <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">checksum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_write_2">Implementing Write</h4>
<div class="paragraph">
<p>Now, let&#8217;s tackle the write problem. As it was mentioned earlier, there is a need to
recognise the type of the iterator used for writing and behave accordingly.
If the iterator is properly defined, the
<a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits">std::iterator_traits</a>
class will define <code>iterator_category</code> internal type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">WriteIteratorCategoryTag</span> <span class="o">=</span>
    <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">WriteIterator</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For random access iterators the <code>WriteIteratorCategoryTag</code> class will be
either <a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags">std::random_access_iterator_tag</a>
or any other class that inherits from it. Using this information, we can use
<a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">Tag Dispatch Idiom</a>
to choose the right writing functionality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ChecksumLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">WriteIteratorCategoryTag</span> <span class="o">=</span>
        <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">WriteIterator</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">;</span>

    <span class="n">ErrorStatus</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeInternal</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">WriteIteratorCategoryTag</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">ErrorStatus</span> <span class="n">writeInternal</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span>
        <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator_tag</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeRandomAccess</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">writeInternal</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span>
        <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">output_iterator_tag</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">writeOutput</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">writeRandomAccess</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">fromIter</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">consumedLen</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">iter</span><span class="p">));</span>
        <span class="k">auto</span> <span class="n">remLen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">consumedLen</span><span class="p">;</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">TCalc</span><span class="p">()(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">consumedLen</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">remLen</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ErrorStatus</span> <span class="n">writeOutput</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WriteIterator</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">UpdateRequired</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please pay attention, that <code>writeOutput()</code> function above is unable to
properly calculate the checksum of the written data. There is no way the
iterator can be reversed back and used as input instead of output. As the
result the function returns special error status: <code>ErrorStatus::UpdateRequired</code>.
It is an indication that the write operation is not complete and the
output should be updated using random access iterator.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_update">Implementing Update</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ChecksumLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">update</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">Field</span> <span class="n">field</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">fromIter</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">m_next</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">consumedLen</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">iter</span><span class="p">));</span>
        <span class="k">auto</span> <span class="n">remLen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">consumedLen</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">=</span> <span class="n">TCalc</span><span class="p">()(</span><span class="n">fromIter</span><span class="p">,</span> <span class="n">consumedLen</span><span class="p">);</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">remLen</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that every other layer must also implement the <code>update()</code> member
function, which will just advance the provided iterator by the number
of bytes required to write its field and invoke <code>update()</code> member function
of the next (wrapped) layer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgDataLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">update</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">comms</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MsgIdLayer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
    <span class="n">ErrorStatus</span> <span class="n">update</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">TNext</span> <span class="n">m_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace comms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on for the rest of the layers. Also note, that the code above will
work, only when the field has the <strong>same serialisation length for any value</strong>.
If this is not the case
(<a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Base-128</a> encoding
is used), the previously written value needs to be read, instead of
just advancing the iterator, to make sure the iterator is advanced
right amount of bytes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TIter</span><span class="o">&gt;</span>
<span class="n">ErrorStatus</span> <span class="n">update</span><span class="p">(</span><span class="n">TIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">TField</span> <span class="n">field</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">m_next</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">field</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable serialisation length encoding will be forced using some kind of
special option. It can be identified at compile time and
<a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">Tag Dispatch Idiom</a>
can be used to select appropriate <code>update</code> functionality.</p>
</div>
<div class="paragraph">
<p>The caller, that requests protocol stack to serialise a message, must check
the error status value returned by the <code>write()</code> operation.
If it is <code>ErrorStatus::UpdateRequired</code>,
the caller must create random-access iterator to the already written buffer
and invoke <code>update()</code> function with it, to make sure the written information
is correct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">ProtocolStack</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">ProtocolStack</span> <span class="n">protStack</span><span class="p">;</span>

<span class="n">ErrorStatus</span> <span class="nf">sendMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ProtocolStack</span><span class="o">::</span><span class="n">WriteIterator</span> <span class="n">writeIter</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">protStack</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">writeIter</span><span class="p">,</span> <span class="n">bufLen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">ErrorStatus</span><span class="o">::</span><span class="n">UpdateRequired</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">updateIter</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// Random access iterator to written data</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">protStack</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">updateIter</span><span class="p">,</span> <span class="p">...);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">es</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transport-stack">Defining Protocol Stack</h3>
<div class="paragraph">
<p>To summarise the protocol <a href="#transport-transport">transport</a> wrapping subject,
let&#8217;s define a custom protocol that wraps the message payload in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>SYNC | SIZE | ID | PAYLOAD | CHECKSUM</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All the fields are serialised using BIG endian.</p>
</li>
<li>
<p>SYNC - 2 bytes of synchronisation value to indicate beginning of the message,
must be "0xab 0xcd"</p>
</li>
<li>
<p>SIZE - 2 bytes, length of remaining data, <strong>including checksum</strong> and not
including SIZE field itself.</p>
</li>
<li>
<p>ID - 1 byte, numeric ID of the message.</p>
</li>
<li>
<p>PAYLOAD - any number of bytes, serialised message data</p>
</li>
<li>
<p>CHECKSUM - 2 bytes, arithmetic summary of all bytes starting (and including)
from SIZE field and ending after PAYLOAD field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The protocol layer should wrap one another in the following way:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/protocol_stack.png" alt="Image: Protcols Stack">
</div>
</div>
<div class="paragraph">
<p>Please note, that <code>CHECKSUM</code> layer doesn&#8217;t wrap <code>SYNC</code> because synchronisation
prefix is not included in the checksum calculation.</p>
</div>
<div class="sect3">
<h4 id="_common_protocol_definitions">Common Protocol Definitions</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// BIG endian fields serialisation</span>
<span class="k">using</span> <span class="n">MyField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Message IDs</span>
<span class="k">enum</span> <span class="n">MyMsgId</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span>
<span class="p">{</span>
    <span class="n">MyMsgId_ActualMessage1</span><span class="p">,</span>
    <span class="n">MyMsgId_ActualMessage2</span><span class="p">,</span>
    <span class="n">MyMsgId_ActualMessage3</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// Forward declaration of MyHandler handling class</span>
<span class="k">class</span> <span class="nc">MyHandler</span><span class="p">;</span>

<span class="c1">// Message interface</span>
<span class="c1">// NOTE: write operation will write data into a vector using push_back() calls</span>
<span class="k">using</span> <span class="n">MyMessage</span> <span class="o">=</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">Message</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">MsgIdType</span><span class="o">&lt;</span><span class="n">MyMsgId</span><span class="o">&gt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">ReadIterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">WriteIterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">LengthInfoInterface</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">Handler</span><span class="o">&lt;</span><span class="n">MyHandler</span><span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Definition of the messages</span>
<span class="k">class</span> <span class="nc">ActualMessage1Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">StaticNumIdImpl</span><span class="o">&lt;</span><span class="n">MyMsgId_ActualMessage1</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">FieldsImpl</span><span class="o">&lt;</span><span class="n">ActualMessage1Fields</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">DispatchImpl</span><span class="o">&lt;</span><span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">TMessage</span><span class="o">&gt;</span>
    <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ActualMessage2Fields</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActualMessage1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">comms</span><span class="o">::</span><span class="n">MessageBase</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="p">...</span>

<span class="c1">// Bundling all messages together</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMessage</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">AllMessages</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
    <span class="n">ActualMessage1</span><span class="o">&lt;</span><span class="n">TMessage</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ActualMessage2</span><span class="o">&lt;</span><span class="n">TMessage</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">...</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_payload_layer">PAYLOAD Layer</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyPayloadLayer</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">MsgDataLayer</span><span class="o">&lt;</span><span class="n">MyMessage</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_id_layer">ID Layer</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyMsgIdField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">EnumValueField</span><span class="o">&lt;</span><span class="n">MyField</span><span class="p">,</span> <span class="n">MyMsgId</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">MyIdLayer</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">MsgIdLayer</span><span class="o">&lt;</span><span class="n">MyMsgIdField</span><span class="p">,</span> <span class="n">AllMessages</span><span class="p">,</span> <span class="n">MyPayloadLayer</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_size_layer">SIZE Layer</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MySizeField</span> <span class="o">=</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span>
        <span class="n">MyField</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">,</span>
        <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">NumValueSerOffset</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MySizeLayer</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">MsgSizeLayer</span><span class="o">&lt;</span><span class="n">MySizeField</span><span class="p">,</span> <span class="n">MyIdLayer</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note, that <code>SIZE</code> field definition uses <code>comms::option::NumValueSerOffset</code>
option, which effectively adds <code>2</code> when size value is serialised, and
subtracts it when remaining length is deserialised. It must be done, because
<code>SIZE</code> value specifies <strong>number of remaining bytes</strong>, including the <code>CHECKSUM</code>
value at the end.</p>
</div>
</div>
<div class="sect3">
<h4 id="_checksum_layer">CHECKSUM Layer</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyChecksumField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span><span class="n">MyField</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MyChecksumLayer</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">ChecksumLayer</span><span class="o">&lt;</span>
    <span class="n">MyChecksumField</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">BasicSum</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span>
    <span class="n">MySizeLayer</span>
<span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sync_layer">SYNC Layer</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MySyncField</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">IntValueField</span><span class="o">&lt;</span>
    <span class="n">MyField</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">,</span>
    <span class="n">comms</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="n">DefaultNumValue</span><span class="o">&lt;</span><span class="mh">0xabcd</span><span class="o">&gt;</span>
<span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">MySyncPrefix</span> <span class="o">=</span> <span class="n">comms</span><span class="o">::</span><span class="n">SyncPrefixLayer</span><span class="o">&lt;</span><span class="n">SyncField</span><span class="p">,</span> <span class="n">MyChecksumLayer</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_processing_loop">Processing Loop</h4>
<div class="paragraph">
<p>The outermost layer defines a full protocol stack. It should be typedef-ed to avoid any confusion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">MyProtocolStack</span> <span class="o">=</span> <span class="n">MySyncPrefix</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The processing loop may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Protocol stack</span>
<span class="n">MyProtocolStack</span> <span class="n">protStack</span><span class="p">;</span>

<span class="c1">// Message handler object</span>
<span class="n">MyHandler</span> <span class="n">handler</span><span class="p">;</span>

<span class="c1">// Input data storage, the data received over I/O link is appended here</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">inData</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">processData</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">inData</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">MyProtocolStack</span><span class="o">::</span><span class="n">ReadIterator</span> <span class="n">readIter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inData</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">MyProtocolStack</span><span class="o">::</span><span class="n">MsgPtr</span> <span class="n">msg</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">protStack</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">readIter</span><span class="p">,</span> <span class="n">inData</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">comms</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">::</span><span class="n">NotEnoughData</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// More data is required;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">comms</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">msgPtr</span><span class="p">);</span> <span class="c1">// Must hold the valid message object</span>
            <span class="n">msgPtr</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span> <span class="c1">// Process message, dispatch to handling function</span>

            <span class="c1">// Erase consumed bytes from the buffer</span>
            <span class="k">auto</span> <span class="n">consumedBytes</span> <span class="o">=</span>
                <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">ProtocolStack</span><span class="o">::</span><span class="n">ReadIterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inData</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">readIter</span><span class="p">);</span>
            <span class="n">inData</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">inData</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">inData</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">consumedBytes</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Some error occurred, pop only one first byte and try to process again</span>
        <span class="n">inData</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">inData</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The processing loop above is not the most efficient one, but it demonstrates
what needs to be done and how our generic library can be used to identify
and process the received message.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_message">Writing Message</h4>
<div class="paragraph">
<p>The write logic is even simpler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">sendMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">MyMessage</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Output buffer</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">outData</span><span class="p">;</span>
    <span class="c1">// Reserve enough space in output buffer</span>
    <span class="n">outData</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">protStack</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="k">auto</span> <span class="n">writeIter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">outData</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">es</span> <span class="o">=</span> <span class="n">protStack</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">writeIter</span><span class="p">,</span> <span class="n">outData</span><span class="p">.</span><span class="n">max_size</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">==</span> <span class="n">comms</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">::</span><span class="n">UpdateRequired</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">updateIter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">outData</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">es</span> <span class="o">=</span> <span class="n">protStack</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">updateIter</span><span class="p">,</span> <span class="n">outData</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">es</span> <span class="o">!=</span> <span class="n">comms</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span> <span class="c1">// report error</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span> <span class="c1">// Send written data over I/O link</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="final">Achievements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After all this effort of creating the generic <code>comms</code> library,
let&#8217;s summarise what has been achieved.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The communication protocol implementation becomes easy and straightforward
process, using mostly declarative statements of classes and types definitions
without unnecessary boilerplate code. The C++ compiler does all the dirty and
boring work of generating the required code.</p>
</li>
<li>
<p>The default logic, provided by the library, can easily be extended and/or
overridden using class inheritance and virtual functions.</p>
</li>
<li>
<p>The protocol implementation doesn&#8217;t enforce any restrictions on data structures
being used, and as a result it can be reused in any system, including bare-metal
ones.</p>
</li>
<li>
<p>There is no dependency on any specific I/O link and the way the data is
being communicated.</p>
</li>
<li>
<p>The application level messages and transport data are completely independent,
which allows usage of the same application level messages over different I/O
links, which require different transport wrapping, at the same time.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix">Appendices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Appendices contain some extra code examples mentioned in this book and can be
used for references.</p>
</div>
<div class="sect2">
<h3 id="appendix-a">Appendix A - tupleForEach</h3>
<div class="paragraph">
<p>Implementation of <code>tupleForEach()</code> function. Namespace <code>details</code> contains some
helper classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">details</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TRem</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachHelper</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">TRem</span> <span class="o">&lt;=</span> <span class="n">TupleSize</span><span class="p">,</span> <span class="s">"Incorrect parameters"</span><span class="p">);</span>

        <span class="c1">// Invoke function with current element</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">TupleSize</span> <span class="o">-</span> <span class="n">TRem</span><span class="p">;</span>
        <span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">)));</span>

        <span class="c1">// Compile time recursion - invoke function with the remaining elements</span>
        <span class="n">TupleForEachHelper</span><span class="o">&lt;</span><span class="n">TRem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachHelper</span><b class="conum">(0)</b>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Stop compile time recursion</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">);</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace details</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">tupleForEach</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>

    <span class="n">details</span><span class="o">::</span><span class="n">TupleForEachHelper</span><span class="o">&lt;</span><span class="n">TupleSize</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-b">Appendix B - tupleAccumulate</h3>
<div class="paragraph">
<p>Implementation of <code>tupleAccumulate()</code> function. Namespace <code>details</code> contains some
helper classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">details</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TRem</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TupleAccumulateHelper</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValue</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">TValue</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="k">const</span> <span class="n">TValue</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">TRem</span> <span class="o">&lt;=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"Incorrect TRem"</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">TupleAccumulateHelper</span><span class="o">&lt;</span><span class="n">TRem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
                    <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">-</span> <span class="n">TRem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">))),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">TupleAccumulateHelper</span><b class="conum">(0)</b>
<span class="p">{</span>

<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValue</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">TValue</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="k">const</span> <span class="n">TValue</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace details</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValue</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">TValue</span> <span class="nf">tupleAccumulate</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="k">const</span> <span class="n">TValue</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">details</span><span class="o">::</span><span class="n">TupleAccumulateHelper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
                <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-c">Appendix C - tupleForEachFromUntil</h3>
<div class="paragraph">
<p>Implementation of <code>tupleAccumulate()</code> function. Namespace <code>details</code> contains some
helper classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">details</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TRem</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TOff</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachFromUntilHelper</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">OffsetedRem</span> <span class="o">=</span> <span class="n">TRem</span> <span class="o">+</span> <span class="n">TOff</span><span class="p">;</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">OffsetedRem</span> <span class="o">&lt;=</span> <span class="n">TupleSize</span><span class="p">,</span> <span class="s">"Incorrect parameters"</span><span class="p">);</span>

        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">TupleSize</span> <span class="o">-</span> <span class="n">OffsetedRem</span><span class="p">;</span>
        <span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">)));</span>
        <span class="n">TupleForEachFromUntilHelper</span><span class="o">&lt;</span><span class="n">TRem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TOff</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TOff</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachFromUntilHelper</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">TOff</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">);</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace details</span>

<span class="c1">// Invoke provided functor for every element in the tuple which indices</span>
<span class="c1">//     are in range [TFromIdx, TUntilIdx).</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TFromIdx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TUntilIdx</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">tupleForEachFromUntil</span><span class="p">(</span><span class="n">TTuple</span><span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">TFromIdx</span> <span class="o">&lt;</span> <span class="n">TupleSize</span><span class="p">,</span>
        <span class="s">"The from index is too big."</span><span class="p">);</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">TUntilIdx</span> <span class="o">&lt;=</span> <span class="n">TupleSize</span><span class="p">,</span>
        <span class="s">"The until index is too big."</span><span class="p">);</span>

    <span class="k">static_assert</span><span class="p">(</span><span class="n">TFromIdx</span> <span class="o">&lt;</span> <span class="n">TUntilIdx</span><span class="p">,</span>
        <span class="s">"The from index must be less than until index."</span><span class="p">);</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">FieldsCount</span> <span class="o">=</span> <span class="n">TUntilIdx</span> <span class="o">-</span> <span class="n">TFromIdx</span><span class="p">;</span>

    <span class="n">details</span><span class="o">::</span><span class="n">TupleForEachFromUntilHelper</span><span class="o">&lt;</span><span class="n">FieldsCount</span><span class="p">,</span> <span class="n">TupleSize</span> <span class="o">-</span> <span class="n">TUntilIdx</span><span class="o">&gt;::</span><span class="n">exec</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-d">Appendix D - tupleForEachType</h3>
<div class="paragraph">
<p>Implementation of <code>tupleForEachType()</code> function. Namespace <code>details</code> contains some
helper classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">details</span>
<span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TRem</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachTypeHelper</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">TRem</span> <span class="o">&lt;=</span> <span class="n">TupleSize</span><span class="p">,</span> <span class="s">"Incorrect TRem"</span><span class="p">);</span>

        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">TupleSize</span> <span class="o">-</span> <span class="n">TRem</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">ElemType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="n">Idx</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="n">func</span><span class="p">.</span><span class="k">template</span> <span class="k">operator</span><span class="p">()</span><span class="o">&lt;</span><span class="n">ElemType</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">TupleForEachTypeHelper</span><span class="o">&lt;</span><span class="n">TRem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">exec</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">TupleForEachTypeHelper</span><b class="conum">(0)</b>
<span class="p">{</span>

<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Nothing to do</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace details</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TTuple</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">tupleForEachType</span><span class="p">(</span><span class="n">TFunc</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">TTuple</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">TupleSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>

    <span class="n">details</span><span class="o">::</span><span class="n">TupleForEachTypeHelper</span><span class="o">&lt;</span><span class="n">TupleSize</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">exec</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">TFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-e">Appendix E - AlignedUnion</h3>
<div class="paragraph">
<p>Implementation of <code>AlignedUnion</code> type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">TTypes</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AlignedUnion</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">OtherStorage</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AlignedUnion</span><span class="o">&lt;</span><span class="n">TTypes</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">OtherSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">OtherStorage</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">OtherAlignment</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">OtherStorage</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">FirstStorage</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">AlignedUnion</span><span class="o">&lt;</span><span class="n">TType</span><span class="o">&gt;::</span><span class="n">Type</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">FirstSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FirstStorage</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">FirstAlignment</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">FirstStorage</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">MaxSize</span> <span class="o">=</span> <span class="n">FirstSize</span> <span class="o">&gt;</span> <span class="n">OtherSize</span> <span class="o">?</span> <span class="n">FirstSize</span> <span class="o">:</span> <span class="n">OtherSize</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">MaxAlignment</span> <span class="o">=</span>
        <span class="n">FirstAlignment</span> <span class="o">&gt;</span> <span class="n">OtherAlignment</span> <span class="o">?</span> <span class="n">FirstAlignment</span> <span class="o">:</span> <span class="n">OtherAlignment</span><span class="p">;</span>
<span class="nl">public:</span>

    <span class="c1">/// Type that has proper size and proper alignment to keep any of the</span>
    <span class="c1">/// specified types</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="n">MaxSize</span><span class="p">,</span> <span class="n">MaxAlignment</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AlignedUnion</span><span class="o">&lt;</span><span class="n">TType</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">Type</span> <span class="o">=</span>
        <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TType</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">TType</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2021-02-17 08:34:39 +1000
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</body>
</html>